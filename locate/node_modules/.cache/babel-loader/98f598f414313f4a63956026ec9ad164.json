{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _nearley = require('nearley');\n\nvar _grammar = require('./grammar');\n\nvar _grammar2 = _interopRequireDefault(_grammar);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/*:: import type {\n  CombinatorTokenType,\n  SelectorTokenType\n} from './types';*/\n// @flow\n\n\nexports.default = function () {\n  var parse = function parse(selector\n  /*: string*/\n  )\n  /*: Array<SelectorTokenType | CombinatorTokenType>*/\n  {\n    var parser = new _nearley.Parser(_grammar2.default.ParserRules, _grammar2.default.ParserStart);\n    var results = parser.feed(selector).results;\n\n    if (results.length === 0) {\n      throw new Error('Found no parsings.');\n    }\n\n    if (results.length > 1) {\n      throw new Error('Ambiguous results.');\n    }\n\n    return results[0];\n  };\n\n  return {\n    parse: parse\n  };\n};","map":{"version":3,"sources":["../src/createParser.js"],"names":["parse","parser","results"],"mappings":";;;;;;AAEA,IAAA,QAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAOA,IAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;;;;;;;;;;;;AATA;;;kBAWe,YAAM;AACnB,MAAMA,KAAAA,GAAQ,SAARA,KAAQ,CAAA;AAAA;AAAA;AAAA;AAAsE;AAClF,QAAMC,MAAAA,GAAS,IAAA,QAAA,CAAA,MAAA,CAAW,SAAA,CAAA,OAAA,CAAX,WAAA,EAAgC,SAAA,CAAA,OAAA,CAA/C,WAAe,CAAf;AAEA,QAAMC,OAAAA,GAAUD,MAAAA,CAAAA,IAAAA,CAAAA,QAAAA,EAAhB,OAAA;;AAEA,QAAIC,OAAAA,CAAAA,MAAAA,KAAJ,CAAA,EAA0B;AACxB,YAAM,IAAA,KAAA,CAAN,oBAAM,CAAN;AACD;;AAED,QAAIA,OAAAA,CAAAA,MAAAA,GAAJ,CAAA,EAAwB;AACtB,YAAM,IAAA,KAAA,CAAN,oBAAM,CAAN;AACD;;AAED,WAAOA,OAAAA,CAAP,CAAOA,CAAP;AAbF,GAAA;;AAgBA,SAAO;AACLF,IAAAA,KAAAA,EAAAA;AADK,GAAP","sourcesContent":["// @flow\n\nimport {\n  Parser\n} from 'nearley';\nimport type {\n  CombinatorTokenType,\n  SelectorTokenType\n} from './types';\nimport grammar from './grammar';\n\nexport default () => {\n  const parse = (selector: string): Array<SelectorTokenType | CombinatorTokenType> => {\n    const parser = new Parser(grammar.ParserRules, grammar.ParserStart);\n\n    const results = parser.feed(selector).results;\n\n    if (results.length === 0) {\n      throw new Error('Found no parsings.');\n    }\n\n    if (results.length > 1) {\n      throw new Error('Ambiguous results.');\n    }\n\n    return results[0];\n  };\n\n  return {\n    parse\n  };\n};\n"]},"metadata":{},"sourceType":"script"}