{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _object = require('object.assign');\n\nvar _object2 = _interopRequireDefault(_object);\n\nvar _arrayPrototype = require('array.prototype.flat');\n\nvar _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);\n\nvar _has = require('has');\n\nvar _has2 = _interopRequireDefault(_has);\n\nvar _Utils = require('./Utils');\n\nvar _getAdapter = require('./getAdapter');\n\nvar _getAdapter2 = _interopRequireDefault(_getAdapter);\n\nvar _Debug = require('./Debug');\n\nvar _RSTTraversal = require('./RSTTraversal');\n\nvar _selectors = require('./selectors');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar NODE = (0, _Utils.sym)('__node__');\nvar NODES = (0, _Utils.sym)('__nodes__');\nvar RENDERER = (0, _Utils.sym)('__renderer__');\nvar UNRENDERED = (0, _Utils.sym)('__unrendered__');\nvar ROOT = (0, _Utils.sym)('__root__');\nvar OPTIONS = (0, _Utils.sym)('__options__');\nvar ROOT_NODES = (0, _Utils.sym)('__rootNodes__');\nvar WRAPPING_COMPONENT = (0, _Utils.sym)('__wrappingComponent__');\nvar LINKED_ROOTS = (0, _Utils.sym)('__linkedRoots__');\nvar UPDATED_BY = (0, _Utils.sym)('__updatedBy__');\n/**\n * Finds all nodes in the current wrapper nodes' render trees that match the provided predicate\n * function.\n *\n * @param {ReactWrapper} wrapper\n * @param {Function} predicate\n * @param {Function} filter\n * @returns {ReactWrapper}\n */\n\nfunction findWhereUnwrapped(wrapper, predicate) {\n  var filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _RSTTraversal.treeFilter;\n  return wrapper.flatMap(function (n) {\n    return filter(n.getNodeInternal(), predicate);\n  });\n}\n/**\n * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n * the provided predicate function.\n *\n * @param {ReactWrapper} wrapper\n * @param {Function} predicate\n * @returns {ReactWrapper}\n */\n\n\nfunction filterWhereUnwrapped(wrapper, predicate) {\n  return wrapper.wrap(wrapper.getNodesInternal().filter(predicate).filter(Boolean));\n}\n\nfunction getRootNodeInternal(wrapper) {\n  if (wrapper[ROOT].length !== 1) {\n    throw new Error('getRootNodeInternal(wrapper) can only be called when wrapper wraps one node');\n  }\n\n  if (wrapper[ROOT] !== wrapper) {\n    return wrapper[ROOT_NODES][0];\n  }\n\n  return wrapper[ROOT][NODE];\n}\n\nfunction nodeParents(wrapper, node) {\n  return (0, _RSTTraversal.parentsOfNode)(node, getRootNodeInternal(wrapper));\n}\n\nfunction privateSetNodes(wrapper, nodes) {\n  if (!nodes) {\n    (0, _Utils.privateSet)(wrapper, NODE, null);\n    (0, _Utils.privateSet)(wrapper, NODES, []);\n  } else if (!Array.isArray(nodes)) {\n    (0, _Utils.privateSet)(wrapper, NODE, nodes);\n    (0, _Utils.privateSet)(wrapper, NODES, [nodes]);\n  } else {\n    (0, _Utils.privateSet)(wrapper, NODE, nodes[0]);\n    (0, _Utils.privateSet)(wrapper, NODES, nodes);\n  }\n\n  (0, _Utils.privateSet)(wrapper, 'length', wrapper[NODES].length);\n}\n/**\n * @class ReactWrapper\n */\n\n\nvar ReactWrapper = function () {\n  function ReactWrapper(nodes, root) {\n    var passedOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, ReactWrapper);\n\n    if (!global.window && !global.document) {\n      throw new Error('It looks like you called `mount()` without a global document being loaded.');\n    }\n\n    var options = (0, _Utils.makeOptions)(passedOptions);\n\n    if (!root) {\n      var adapter = (0, _getAdapter2['default'])(options);\n\n      if (!adapter.isValidElement(nodes)) {\n        throw new TypeError('ReactWrapper can only wrap valid elements');\n      }\n\n      var renderer = adapter.createRenderer((0, _object2['default'])({\n        mode: 'mount'\n      }, options));\n      (0, _Utils.privateSet)(this, RENDERER, renderer);\n      renderer.render(nodes, options.context);\n      (0, _Utils.privateSet)(this, ROOT, this);\n      privateSetNodes(this, this[RENDERER].getNode());\n      (0, _Utils.privateSet)(this, OPTIONS, options);\n      (0, _Utils.privateSet)(this, LINKED_ROOTS, []);\n\n      if ((0, _Utils.isCustomComponent)(options.wrappingComponent, adapter)) {\n        if (typeof this[RENDERER].getWrappingComponentRenderer !== 'function') {\n          throw new TypeError('your adapter does not support `wrappingComponent`. Try upgrading it!');\n        } // eslint-disable-next-line no-use-before-define\n\n\n        (0, _Utils.privateSet)(this, WRAPPING_COMPONENT, new WrappingComponentWrapper(this, this[RENDERER].getWrappingComponentRenderer()));\n        this[LINKED_ROOTS].push(this[WRAPPING_COMPONENT]);\n      }\n    } else {\n      (0, _Utils.privateSet)(this, RENDERER, root[RENDERER]);\n      (0, _Utils.privateSet)(this, ROOT, root);\n      privateSetNodes(this, nodes);\n      (0, _Utils.privateSet)(this, ROOT_NODES, root[NODES]);\n      (0, _Utils.privateSet)(this, OPTIONS, root[OPTIONS]);\n      (0, _Utils.privateSet)(this, LINKED_ROOTS, []);\n    }\n\n    (0, _Utils.privateSet)(this, UNRENDERED, nodes);\n    (0, _Utils.privateSet)(this, UPDATED_BY, null);\n  }\n  /**\n   * Returns the root wrapper\n   *\n   * @return {ReactWrapper}\n   */\n\n\n  _createClass(ReactWrapper, [{\n    key: 'root',\n    value: function () {\n      function root() {\n        return this[ROOT];\n      }\n\n      return root;\n    }()\n    /**\n     * Returns the wrapped component.\n     *\n     * @return {ReactComponent}\n     */\n\n  }, {\n    key: 'getNodeInternal',\n    value: function () {\n      function getNodeInternal() {\n        if (this.length !== 1) {\n          throw new Error('ReactWrapper::getNode() can only be called when wrapping one node');\n        }\n\n        return this[NODES][0];\n      }\n\n      return getNodeInternal;\n    }()\n    /**\n     * Returns the the wrapped components.\n     *\n     * @return {Array<ReactComponent>}\n     */\n\n  }, {\n    key: 'getNodesInternal',\n    value: function () {\n      function getNodesInternal() {\n        return this[NODES];\n      }\n\n      return getNodesInternal;\n    }()\n    /**\n     * Returns the wrapped ReactElement.\n     *\n     * @return {ReactElement}\n     */\n\n  }, {\n    key: 'getElement',\n    value: function () {\n      function getElement() {\n        var _this = this;\n\n        return this.single('getElement', function () {\n          return (0, _getAdapter2['default'])(_this[OPTIONS]).nodeToElement(_this[NODE]);\n        });\n      }\n\n      return getElement;\n    }()\n    /**\n     * Returns the wrapped ReactElements.\n     *\n     * @return {Array<ReactElement>}\n     */\n\n  }, {\n    key: 'getElements',\n    value: function () {\n      function getElements() {\n        var _this2 = this;\n\n        return this[NODES].map(function (n) {\n          return (0, _getAdapter2['default'])(_this2[OPTIONS]).nodeToElement(n);\n        });\n      }\n\n      return getElements;\n    }() // eslint-disable-next-line class-methods-use-this\n\n  }, {\n    key: 'getNode',\n    value: function () {\n      function getNode() {\n        throw new Error('ReactWrapper::getNode() is no longer supported. Use ReactWrapper::instance() instead');\n      }\n\n      return getNode;\n    }() // eslint-disable-next-line class-methods-use-this\n\n  }, {\n    key: 'getNodes',\n    value: function () {\n      function getNodes() {\n        throw new Error('ReactWrapper::getNodes() is no longer supported.');\n      }\n\n      return getNodes;\n    }()\n    /**\n     * Returns the outer most DOMComponent of the current wrapper.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @returns {DOMComponent}\n     */\n\n  }, {\n    key: 'getDOMNode',\n    value: function () {\n      function getDOMNode() {\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n        return this.single('getDOMNode', function (n) {\n          return adapter.nodeToHostNode(n, true);\n        });\n      }\n\n      return getDOMNode;\n    }()\n    /**\n     * If the root component contained a ref, you can access it here and get the relevant\n     * react component instance or HTML element instance.\n     *\n     * NOTE: can only be called on a wrapper instance that is also the root instance.\n     *\n     * @param {String} refname\n     * @returns {ReactComponent | HTMLElement}\n     */\n\n  }, {\n    key: 'ref',\n    value: function () {\n      function ref(refname) {\n        if (this[ROOT] !== this) {\n          throw new Error('ReactWrapper::ref(refname) can only be called on the root');\n        }\n\n        return this.instance().refs[refname];\n      }\n\n      return ref;\n    }()\n    /**\n     * Returns the wrapper's underlying instance.\n     *\n     * Example:\n     * ```\n     * const wrapper = mount(<MyComponent />);\n     * const inst = wrapper.instance();\n     * expect(inst).to.be.instanceOf(MyComponent);\n     * ```\n     * @returns {ReactComponent|DOMComponent}\n     */\n\n  }, {\n    key: 'instance',\n    value: function () {\n      function instance() {\n        var _this3 = this;\n\n        return this.single('instance', function () {\n          return _this3[NODE].instance;\n        });\n      }\n\n      return instance;\n    }()\n    /**\n     * If a `wrappingComponent` was passed in `options`, this methods returns a `ReactWrapper` around\n     * the rendered `wrappingComponent`. This `ReactWrapper` can be used to update the\n     * `wrappingComponent`'s props, state, etc.\n     *\n     * @returns ReactWrapper\n     */\n\n  }, {\n    key: 'getWrappingComponent',\n    value: function () {\n      function getWrappingComponent() {\n        if (this[ROOT] !== this) {\n          throw new Error('ReactWrapper::getWrappingComponent() can only be called on the root');\n        }\n\n        if (!this[OPTIONS].wrappingComponent) {\n          throw new Error('ReactWrapper::getWrappingComponent() can only be called on a wrapper that was originally passed a `wrappingComponent` option');\n        }\n\n        return this[WRAPPING_COMPONENT];\n      }\n\n      return getWrappingComponent;\n    }()\n    /**\n     * Forces a re-render. Useful to run before checking the render output if something external\n     * may be updating the state of the component somewhere.\n     *\n     * NOTE: no matter what instance this is called on, it will always update the root.\n     *\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'update',\n    value: function () {\n      function update() {\n        var _this4 = this;\n\n        var root = this[ROOT];\n\n        if (this !== root) {\n          return root.update();\n        }\n\n        privateSetNodes(this, this[RENDERER].getNode());\n        this[LINKED_ROOTS].forEach(function (linkedRoot) {\n          if (linkedRoot !== _this4[UPDATED_BY]) {\n            /* eslint-disable no-param-reassign */\n            // Only update a linked it root if it is not the originator of our update().\n            // This is needed to prevent infinite recursion when there is a bi-directional\n            // link between two roots.\n            linkedRoot[UPDATED_BY] = _this4;\n\n            try {\n              linkedRoot.update();\n            } finally {\n              linkedRoot[UPDATED_BY] = null;\n            }\n          }\n        });\n        return this;\n      }\n\n      return update;\n    }()\n    /**\n     * A method that unmounts the component. This can be used to simulate a component going through\n     * and unmount/mount lifecycle.\n     *\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'unmount',\n    value: function () {\n      function unmount() {\n        var _this5 = this;\n\n        if (this[ROOT] !== this) {\n          throw new Error('ReactWrapper::unmount() can only be called on the root');\n        }\n\n        this.single('unmount', function () {\n          _this5[RENDERER].unmount();\n\n          _this5.update();\n        });\n        return this;\n      }\n\n      return unmount;\n    }()\n    /**\n     * A method that re-mounts the component, if it is not currently mounted.\n     * This can be used to simulate a component going through\n     * an unmount/mount lifecycle.\n     *\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'mount',\n    value: function () {\n      function mount() {\n        var _this6 = this;\n\n        if (this[ROOT] !== this) {\n          throw new Error('ReactWrapper::mount() can only be called on the root');\n        }\n\n        this[RENDERER].render(this[UNRENDERED], this[OPTIONS].context, function () {\n          return _this6.update();\n        });\n        return this;\n      }\n\n      return mount;\n    }()\n    /**\n     * A method that sets the props of the root component, and re-renders. Useful for when you are\n     * wanting to test how the component behaves over time with changing props. Calling this, for\n     * instance, will call the `componentWillReceiveProps` lifecycle method.\n     *\n     * Similar to `setState`, this method accepts a props object and will merge it in with the already\n     * existing props.\n     *\n     * NOTE: can only be called on a wrapper instance that is also the root instance.\n     *\n     * @param {Object} props object\n     * @param {Function} cb - callback function\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'setProps',\n    value: function () {\n      function setProps(props) {\n        var _this7 = this;\n\n        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n        if (this[ROOT] !== this) {\n          throw new Error('ReactWrapper::setProps() can only be called on the root');\n        }\n\n        if (arguments.length > 1 && typeof callback !== 'function') {\n          throw new TypeError('ReactWrapper::setProps() expects a function as its second argument');\n        }\n\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n        this[UNRENDERED] = (0, _Utils.cloneElement)(adapter, this[UNRENDERED], props);\n        this[RENDERER].render(this[UNRENDERED], null, function () {\n          _this7.update();\n\n          if (callback) {\n            callback();\n          }\n        });\n        return this;\n      }\n\n      return setProps;\n    }()\n    /**\n     * A method to invoke `setState` on the root component instance similar to how you might in the\n     * definition of the component, and re-renders.  This method is useful for testing your component\n     * in hard to achieve states, however should be used sparingly. If possible, you should utilize\n     * your component's external API in order to get it into whatever state you want to test, in order\n     * to be as accurate of a test as possible. This is not always practical, however.\n     *\n     * NOTE: can only be called on a wrapper instance that is also the root instance.\n     *\n     * @param {Object} state to merge\n     * @param {Function} cb - callback function\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'setState',\n    value: function () {\n      function setState(state) {\n        var _this8 = this;\n\n        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n        if (this.instance() === null || this.getNodeInternal().nodeType !== 'class') {\n          throw new Error('ReactWrapper::setState() can only be called on class components');\n        }\n\n        if (arguments.length > 1 && typeof callback !== 'function') {\n          throw new TypeError('ReactWrapper::setState() expects a function as its second argument');\n        }\n\n        this.instance().setState(state, function () {\n          _this8.update();\n\n          if (callback) {\n            var adapter = (0, _getAdapter2['default'])(_this8[OPTIONS]);\n\n            var instance = _this8.instance();\n\n            if (adapter.invokeSetStateCallback) {\n              adapter.invokeSetStateCallback(instance, callback);\n            } else {\n              callback.call(instance);\n            }\n          }\n        });\n        return this;\n      }\n\n      return setState;\n    }()\n    /**\n     * A method that sets the context of the root component, and re-renders. Useful for when you are\n     * wanting to test how the component behaves over time with changing contexts.\n     *\n     * NOTE: can only be called on a wrapper instance that is also the root instance.\n     *\n     * @param {Object} context object\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'setContext',\n    value: function () {\n      function setContext(context) {\n        var _this9 = this;\n\n        if (this[ROOT] !== this) {\n          throw new Error('ReactWrapper::setContext() can only be called on the root');\n        }\n\n        if (!this[OPTIONS].context) {\n          throw new Error('ReactWrapper::setContext() can only be called on a wrapper that was originally passed a context option');\n        }\n\n        this[RENDERER].render(this[UNRENDERED], context, function () {\n          return _this9.update();\n        });\n        return this;\n      }\n\n      return setContext;\n    }()\n    /**\n     * Whether or not a given react element exists in the mount render tree.\n     *\n     * Example:\n     * ```\n     * const wrapper = mount(<MyComponent />);\n     * expect(wrapper.contains(<div className=\"foo bar\" />)).to.equal(true);\n     * ```\n     *\n     * @param {ReactElement|Array<ReactElement>} nodeOrNodes\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'contains',\n    value: function () {\n      function contains(nodeOrNodes) {\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n        var predicate = Array.isArray(nodeOrNodes) ? function (other) {\n          return (0, _Utils.containsChildrenSubArray)(_Utils.nodeEqual, other, nodeOrNodes.map(function (node) {\n            return adapter.elementToNode(node);\n          }));\n        } : function (other) {\n          return (0, _Utils.nodeEqual)(adapter.elementToNode(nodeOrNodes), other);\n        };\n        return findWhereUnwrapped(this, predicate).length > 0;\n      }\n\n      return contains;\n    }()\n    /**\n     * Whether or not a given react element exists in the current render tree.\n     * It will determine if one of the wrappers element \"looks like\" the expected\n     * element by checking if all props of the expected element are present\n     * on the wrappers element and equals to each other.\n     *\n     * Example:\n     * ```\n     * // MyComponent outputs <div><div class=\"foo\">Hello</div></div>\n     * const wrapper = mount(<MyComponent />);\n     * expect(wrapper.containsMatchingElement(<div>Hello</div>)).to.equal(true);\n     * ```\n     *\n     * @param {ReactElement} node\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'containsMatchingElement',\n    value: function () {\n      function containsMatchingElement(node) {\n        var rstNode = (0, _getAdapter2['default'])(this[OPTIONS]).elementToNode(node);\n\n        var predicate = function () {\n          function predicate(other) {\n            return (0, _Utils.nodeMatches)(rstNode, other, function (a, b) {\n              return a <= b;\n            });\n          }\n\n          return predicate;\n        }();\n\n        return findWhereUnwrapped(this, predicate).length > 0;\n      }\n\n      return containsMatchingElement;\n    }()\n    /**\n     * Whether or not all the given react elements exist in the current render tree.\n     * It will determine if one of the wrappers element \"looks like\" the expected\n     * element by checking if all props of the expected element are present\n     * on the wrappers element and equals to each other.\n     *\n     * Example:\n     * ```\n     * const wrapper = mount(<MyComponent />);\n     * expect(wrapper.containsAllMatchingElements([\n     *   <div>Hello</div>,\n     *   <div>Goodbye</div>,\n     * ])).to.equal(true);\n     * ```\n     *\n     * @param {Array<ReactElement>} nodes\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'containsAllMatchingElements',\n    value: function () {\n      function containsAllMatchingElements(nodes) {\n        var _this10 = this;\n\n        if (!Array.isArray(nodes)) {\n          throw new TypeError('nodes should be an Array');\n        }\n\n        return nodes.every(function (node) {\n          return _this10.containsMatchingElement(node);\n        });\n      }\n\n      return containsAllMatchingElements;\n    }()\n    /**\n     * Whether or not one of the given react elements exists in the current render tree.\n     * It will determine if one of the wrappers element \"looks like\" the expected\n     * element by checking if all props of the expected element are present\n     * on the wrappers element and equals to each other.\n     *\n     * Example:\n     * ```\n     * const wrapper = mount(<MyComponent />);\n     * expect(wrapper.containsAnyMatchingElements([\n     *   <div>Hello</div>,\n     *   <div>Goodbye</div>,\n     * ])).to.equal(true);\n     * ```\n     *\n     * @param {Array<ReactElement>} nodes\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'containsAnyMatchingElements',\n    value: function () {\n      function containsAnyMatchingElements(nodes) {\n        var _this11 = this;\n\n        return Array.isArray(nodes) && nodes.some(function (node) {\n          return _this11.containsMatchingElement(node);\n        });\n      }\n\n      return containsAnyMatchingElements;\n    }()\n    /**\n     * Whether or not a given react element exists in the render tree.\n     *\n     * Example:\n     * ```\n     * const wrapper = mount(<MyComponent />);\n     * expect(wrapper.contains(<div className=\"foo bar\" />)).to.equal(true);\n     * ```\n     *\n     * @param {ReactElement} node\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'equals',\n    value: function () {\n      function equals(node) {\n        var _this12 = this;\n\n        return this.single('equals', function () {\n          return (0, _Utils.nodeEqual)(_this12.getNodeInternal(), node);\n        });\n      }\n\n      return equals;\n    }()\n    /**\n     * Whether or not a given react element matches the render tree.\n     * Match is based on the expected element and not on wrapper root node.\n     * It will determine if the wrapper root node \"looks like\" the expected\n     * element by checking if all props of the expected element are present\n     * on the wrapper root node and equals to each other.\n     *\n     * Example:\n     * ```\n     * // MyComponent outputs <div class=\"foo\">Hello</div>\n     * const wrapper = mount(<MyComponent />);\n     * expect(wrapper.matchesElement(<div>Hello</div>)).to.equal(true);\n     * ```\n     *\n     * @param {ReactElement} node\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'matchesElement',\n    value: function () {\n      function matchesElement(node) {\n        var _this13 = this;\n\n        return this.single('matchesElement', function () {\n          var adapter = (0, _getAdapter2['default'])(_this13[OPTIONS]);\n          var rstNode = adapter.elementToNode(node);\n          return (0, _Utils.nodeMatches)(rstNode, _this13.getNodeInternal(), function (a, b) {\n            return a <= b;\n          });\n        });\n      }\n\n      return matchesElement;\n    }()\n    /**\n     * Finds every node in the render tree of the current wrapper that matches the provided selector.\n     *\n     * @param {EnzymeSelector} selector\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'find',\n    value: function () {\n      function find(selector) {\n        return this.wrap((0, _selectors.reduceTreesBySelector)(selector, this.getNodesInternal()));\n      }\n\n      return find;\n    }()\n    /**\n     * Returns whether or not current node matches a provided selector.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @param {EnzymeSelector} selector\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'is',\n    value: function () {\n      function is(selector) {\n        var predicate = (0, _selectors.buildPredicate)(selector);\n        return this.single('is', function (n) {\n          return predicate(n);\n        });\n      }\n\n      return is;\n    }()\n    /**\n     * Returns true if the component rendered nothing, i.e., null or false.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'isEmptyRender',\n    value: function () {\n      function isEmptyRender() {\n        var nodes = this.getNodeInternal();\n        return (0, _Utils.renderedDive)(nodes);\n      }\n\n      return isEmptyRender;\n    }()\n    /**\n     * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n     * the provided predicate function.\n     *\n     * @param {Function} predicate\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'filterWhere',\n    value: function () {\n      function filterWhere(predicate) {\n        var _this14 = this;\n\n        return filterWhereUnwrapped(this, function (n) {\n          return predicate(_this14.wrap(n));\n        });\n      }\n\n      return filterWhere;\n    }()\n    /**\n     * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n     * the provided selector.\n     *\n     * @param {EnzymeSelector} selector\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'filter',\n    value: function () {\n      function filter(selector) {\n        var predicate = (0, _selectors.buildPredicate)(selector);\n        return filterWhereUnwrapped(this, predicate);\n      }\n\n      return filter;\n    }()\n    /**\n     * Returns a new wrapper instance with only the nodes of the current wrapper that did not match\n     * the provided selector. Essentially the inverse of `filter`.\n     *\n     * @param {EnzymeSelector} selector\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'not',\n    value: function () {\n      function not(selector) {\n        var predicate = (0, _selectors.buildPredicate)(selector);\n        return filterWhereUnwrapped(this, function (n) {\n          return !predicate(n);\n        });\n      }\n\n      return not;\n    }()\n    /**\n     * Returns a string of the rendered text of the current render tree.  This function should be\n     * looked at with skepticism if being used to test what the actual HTML output of the component\n     * will be. If that is what you would like to test, use enzyme's `render` function instead.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @returns {String}\n     */\n\n  }, {\n    key: 'text',\n    value: function () {\n      function text() {\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n        return this.single('text', function (n) {\n          return (0, _RSTTraversal.getTextFromHostNodes)(n, adapter);\n        });\n      }\n\n      return text;\n    }()\n    /**\n     * Returns the HTML of the node.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @returns {String}\n     */\n\n  }, {\n    key: 'html',\n    value: function () {\n      function html() {\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n        return this.single('html', function (n) {\n          return (0, _RSTTraversal.getHTMLFromHostNodes)(n, adapter);\n        });\n      }\n\n      return html;\n    }()\n    /**\n     * Returns the current node rendered to HTML and wrapped in a CheerioWrapper.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @returns {CheerioWrapper}\n     */\n\n  }, {\n    key: 'render',\n    value: function () {\n      function render() {\n        var html = this.html();\n        return (0, _Utils.loadCheerioRoot)(html);\n      }\n\n      return render;\n    }()\n    /**\n     * Used to simulate events. Pass an eventname and (optionally) event arguments. This method of\n     * testing events should be met with some skepticism.\n     *\n     * @param {String} event\n     * @param {Object} mock (optional)\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'simulate',\n    value: function () {\n      function simulate(event) {\n        var _this15 = this;\n\n        var mock = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return this.single('simulate', function (n) {\n          _this15[RENDERER].simulateEvent(n, event, mock);\n\n          _this15[ROOT].update();\n\n          return _this15;\n        });\n      }\n\n      return simulate;\n    }()\n    /**\n     * Used to simulate throwing a rendering error. Pass an error to throw.\n     *\n     * @param {String} error\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'simulateError',\n    value: function () {\n      function simulateError(error) {\n        var _this16 = this;\n\n        if (this[ROOT] === this) {\n          throw new Error('ReactWrapper::simulateError() may not be called on the root');\n        }\n\n        return this.single('simulateError', function (thisNode) {\n          if (thisNode.nodeType === 'host') {\n            throw new Error('ReactWrapper::simulateError() can only be called on custom components');\n          }\n\n          var renderer = _this16[RENDERER];\n\n          if (typeof renderer.simulateError !== 'function') {\n            throw new TypeError('your adapter does not support `simulateError`. Try upgrading it!');\n          }\n\n          var rootNode = getRootNodeInternal(_this16);\n          var nodeHierarchy = [thisNode].concat(nodeParents(_this16, thisNode));\n          renderer.simulateError(nodeHierarchy, rootNode, error);\n\n          _this16[ROOT].update();\n\n          return _this16;\n        });\n      }\n\n      return simulateError;\n    }()\n    /**\n     * Returns the props hash for the root node of the wrapper.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'props',\n    value: function () {\n      function props() {\n        return this.single('props', _RSTTraversal.propsOfNode);\n      }\n\n      return props;\n    }()\n    /**\n     * Returns the state hash for the root node of the wrapper. Optionally pass in a prop name and it\n     * will return just that value.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @param {String} name (optional)\n     * @returns {*}\n     */\n\n  }, {\n    key: 'state',\n    value: function () {\n      function state(name) {\n        var _this17 = this;\n\n        var thisNode = this[ROOT] === this ? this[RENDERER].getNode() : this.getNodeInternal();\n\n        if (this.instance() === null || thisNode.nodeType !== 'class') {\n          throw new Error('ReactWrapper::state() can only be called on class components');\n        }\n\n        var _state = this.single('state', function () {\n          return _this17.instance().state;\n        });\n\n        if (typeof name !== 'undefined') {\n          if (_state == null) {\n            throw new TypeError('ReactWrapper::state(\"' + String(name) + '\") requires that `state` not be `null` or `undefined`');\n          }\n\n          return _state[name];\n        }\n\n        return _state;\n      }\n\n      return state;\n    }()\n    /**\n     * Returns the context hash for the root node of the wrapper.\n     * Optionally pass in a prop name and it will return just that value.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @param {String} name (optional)\n     * @returns {*}\n     */\n\n  }, {\n    key: 'context',\n    value: function () {\n      function context(name) {\n        var _this18 = this;\n\n        if (this[ROOT] !== this) {\n          throw new Error('ReactWrapper::context() can only be called on the root');\n        }\n\n        var instance = this.single('context', function () {\n          return _this18.instance();\n        });\n\n        if (instance === null) {\n          throw new Error('ReactWrapper::context() can only be called on components with instances');\n        }\n\n        var _context = instance.context;\n\n        if (typeof name !== 'undefined') {\n          return _context[name];\n        }\n\n        return _context;\n      }\n\n      return context;\n    }()\n    /**\n     * Returns a new wrapper with all of the children of the current wrapper.\n     *\n     * @param {EnzymeSelector} [selector]\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'children',\n    value: function () {\n      function children(selector) {\n        var allChildren = this.flatMap(function (n) {\n          return (0, _RSTTraversal.childrenOfNode)(n.getNodeInternal());\n        });\n        return selector ? allChildren.filter(selector) : allChildren;\n      }\n\n      return children;\n    }()\n    /**\n     * Returns a new wrapper with a specific child\n     *\n     * @param {Number} [index]\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'childAt',\n    value: function () {\n      function childAt(index) {\n        var _this19 = this;\n\n        return this.single('childAt', function () {\n          return _this19.children().at(index);\n        });\n      }\n\n      return childAt;\n    }()\n    /**\n     * Returns a wrapper around all of the parents/ancestors of the wrapper. Does not include the node\n     * in the current wrapper.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @param {EnzymeSelector} [selector]\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'parents',\n    value: function () {\n      function parents(selector) {\n        var _this20 = this;\n\n        return this.single('parents', function (n) {\n          var allParents = _this20.wrap(nodeParents(_this20, n));\n\n          return selector ? allParents.filter(selector) : allParents;\n        });\n      }\n\n      return parents;\n    }()\n    /**\n     * Returns a wrapper around the immediate parent of the current node.\n     *\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'parent',\n    value: function () {\n      function parent() {\n        return this.flatMap(function (n) {\n          return [n.parents().get(0)];\n        });\n      }\n\n      return parent;\n    }()\n    /**\n     *\n     * @param {EnzymeSelector} selector\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'closest',\n    value: function () {\n      function closest(selector) {\n        if (this.is(selector)) {\n          return this;\n        }\n\n        var matchingAncestors = this.parents().filter(selector);\n        return matchingAncestors.length > 0 ? matchingAncestors.first() : this.findWhere(function () {\n          return false;\n        });\n      }\n\n      return closest;\n    }()\n    /**\n     * Returns the value of  prop with the given name of the root node.\n     *\n     * @param {String} propName\n     * @returns {*}\n     */\n\n  }, {\n    key: 'prop',\n    value: function () {\n      function prop(propName) {\n        return this.props()[propName];\n      }\n\n      return prop;\n    }()\n    /**\n     * Used to invoke a function prop.\n     * Will invoke an function prop and return its value.\n     *\n     * @param {String} propName\n     * @returns {Any}\n     */\n\n  }, {\n    key: 'invoke',\n    value: function () {\n      function invoke(propName) {\n        var _this21 = this;\n\n        return this.single('invoke', function () {\n          var handler = _this21.prop(propName);\n\n          if (typeof handler !== 'function') {\n            throw new TypeError('ReactWrapper::invoke() requires the name of a prop whose value is a function');\n          }\n\n          return function () {\n            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            var response = typeof _this21[RENDERER].wrapInvoke === 'function' ? _this21[RENDERER].wrapInvoke(function () {\n              return handler.apply(undefined, args);\n            }) : handler.apply(undefined, args);\n\n            _this21[ROOT].update();\n\n            return response;\n          };\n        });\n      }\n\n      return invoke;\n    }()\n    /**\n     * Returns a wrapper of the node rendered by the provided render prop.\n     *\n     * @param {String} propName\n     * @returns {Function}\n     */\n\n  }, {\n    key: 'renderProp',\n    value: function () {\n      function renderProp(propName) {\n        var _this22 = this;\n\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n\n        if (typeof adapter.wrap !== 'function') {\n          throw new RangeError('your adapter does not support `wrap`. Try upgrading it!');\n        }\n\n        return this.single('renderProp', function (n) {\n          if (n.nodeType === 'host') {\n            throw new TypeError('ReactWrapper::renderProp() can only be called on custom components');\n          }\n\n          if (typeof propName !== 'string') {\n            throw new TypeError('ReactWrapper::renderProp(): `propName` must be a string');\n          }\n\n          var props = _this22.props();\n\n          if (!(0, _has2['default'])(props, propName)) {\n            throw new Error('ReactWrapper::renderProp(): no prop called \\u201C' + String(propName) + '\\u201C found');\n          }\n\n          var propValue = props[propName];\n\n          if (typeof propValue !== 'function') {\n            throw new TypeError('ReactWrapper::renderProp(): expected prop \\u201C' + String(propName) + '\\u201C to contain a function, but it holds \\u201C' + (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) + '\\u201C');\n          }\n\n          return function () {\n            var element = propValue.apply(undefined, arguments);\n            var wrapped = adapter.wrap(element);\n            return _this22.wrap(wrapped, null, _this22[OPTIONS]);\n          };\n        });\n      }\n\n      return renderProp;\n    }()\n    /**\n     * Returns the key assigned to the current node.\n     *\n     * @returns {String}\n     */\n\n  }, {\n    key: 'key',\n    value: function () {\n      function key() {\n        return this.single('key', function (n) {\n          return n.key === undefined ? null : n.key;\n        });\n      }\n\n      return key;\n    }()\n    /**\n     * Returns the type of the root node of this wrapper. If it's a composite component, this will be\n     * the component constructor. If it's native DOM node, it will be a string.\n     *\n     * @returns {String|Function}\n     */\n\n  }, {\n    key: 'type',\n    value: function () {\n      function type() {\n        return this.single('type', function (n) {\n          return (0, _Utils.typeOfNode)(n);\n        });\n      }\n\n      return type;\n    }()\n    /**\n     * Returns the name of the root node of this wrapper.\n     *\n     * In order of precedence => type.displayName -> type.name -> type.\n     *\n     * @returns {String}\n     */\n\n  }, {\n    key: 'name',\n    value: function () {\n      function name() {\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n        return this.single('name', function (n) {\n          return adapter.displayNameOfNode ? adapter.displayNameOfNode(n) : (0, _Utils.displayNameOfNode)(n);\n        });\n      }\n\n      return name;\n    }()\n    /**\n     * Returns whether or not the current root node has the given class name or not.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @param {String} className\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'hasClass',\n    value: function () {\n      function hasClass(className) {\n        if (typeof className === 'string' && className.indexOf('.') !== -1) {\n          // eslint-disable-next-line no-console\n          console.warn('It looks like you\\'re calling `ReactWrapper::hasClass()` with a CSS selector. hasClass() expects a class name, not a CSS selector.');\n        }\n\n        return this.single('hasClass', function (n) {\n          return (0, _RSTTraversal.hasClassName)(n, className);\n        });\n      }\n\n      return hasClass;\n    }()\n    /**\n     * Iterates through each node of the current wrapper and executes the provided function with a\n     * wrapper around the corresponding node passed in as the first argument.\n     *\n     * @param {Function} fn\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'forEach',\n    value: function () {\n      function forEach(fn) {\n        var _this23 = this;\n\n        this.getNodesInternal().forEach(function (n, i) {\n          return fn.call(_this23, _this23.wrap(n), i);\n        });\n        return this;\n      }\n\n      return forEach;\n    }()\n    /**\n     * Maps the current array of nodes to another array. Each node is passed in as a `ReactWrapper`\n     * to the map function.\n     *\n     * @param {Function} fn\n     * @returns {Array}\n     */\n\n  }, {\n    key: 'map',\n    value: function () {\n      function map(fn) {\n        var _this24 = this;\n\n        return this.getNodesInternal().map(function (n, i) {\n          return fn.call(_this24, _this24.wrap(n), i);\n        });\n      }\n\n      return map;\n    }()\n    /**\n     * Reduces the current array of nodes to another array.\n     * Each node is passed in as a `ShallowWrapper` to the reducer function.\n     *\n     * @param {Function} fn - the reducer function\n     * @param {*} initialValue - the initial value\n     * @returns {*}\n     */\n\n  }, {\n    key: 'reduce',\n    value: function () {\n      function reduce(fn) {\n        var _this25 = this;\n\n        var initialValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n        if (arguments.length > 1) {\n          return this.getNodesInternal().reduce(function (accum, n, i) {\n            return fn.call(_this25, accum, _this25.wrap(n), i);\n          }, initialValue);\n        }\n\n        return this.getNodesInternal().reduce(function (accum, n, i) {\n          return fn.call(_this25, i === 1 ? _this25.wrap(accum) : accum, _this25.wrap(n), i);\n        });\n      }\n\n      return reduce;\n    }()\n    /**\n     * Reduces the current array of nodes to another array, from right to left. Each node is passed\n     * in as a `ShallowWrapper` to the reducer function.\n     *\n     * @param {Function} fn - the reducer function\n     * @param {*} initialValue - the initial value\n     * @returns {*}\n     */\n\n  }, {\n    key: 'reduceRight',\n    value: function () {\n      function reduceRight(fn) {\n        var _this26 = this;\n\n        var initialValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n        if (arguments.length > 1) {\n          return this.getNodesInternal().reduceRight(function (accum, n, i) {\n            return fn.call(_this26, accum, _this26.wrap(n), i);\n          }, initialValue);\n        }\n\n        return this.getNodesInternal().reduceRight(function (accum, n, i) {\n          return fn.call(_this26, i === 1 ? _this26.wrap(accum) : accum, _this26.wrap(n), i);\n        });\n      }\n\n      return reduceRight;\n    }()\n    /**\n     * Returns a new wrapper with a subset of the nodes of the original wrapper, according to the\n     * rules of `Array#slice`.\n     *\n     * @param {Number} begin\n     * @param {Number} end\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'slice',\n    value: function () {\n      function slice(begin, end) {\n        return this.wrap(this.getNodesInternal().slice(begin, end));\n      }\n\n      return slice;\n    }()\n    /**\n     * Returns whether or not any of the nodes in the wrapper match the provided selector.\n     *\n     * @param {EnzymeSelector} selector\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'some',\n    value: function () {\n      function some(selector) {\n        if (this[ROOT] === this) {\n          throw new Error('ReactWrapper::some() can not be called on the root');\n        }\n\n        var predicate = (0, _selectors.buildPredicate)(selector);\n        return this.getNodesInternal().some(predicate);\n      }\n\n      return some;\n    }()\n    /**\n     * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.\n     *\n     * @param {Function} predicate\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'someWhere',\n    value: function () {\n      function someWhere(predicate) {\n        var _this27 = this;\n\n        return this.getNodesInternal().some(function (n, i) {\n          return predicate.call(_this27, _this27.wrap(n), i);\n        });\n      }\n\n      return someWhere;\n    }()\n    /**\n     * Returns whether or not all of the nodes in the wrapper match the provided selector.\n     *\n     * @param {EnzymeSelector} selector\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'every',\n    value: function () {\n      function every(selector) {\n        var predicate = (0, _selectors.buildPredicate)(selector);\n        return this.getNodesInternal().every(predicate);\n      }\n\n      return every;\n    }()\n    /**\n     * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.\n     *\n     * @param {Function} predicate\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'everyWhere',\n    value: function () {\n      function everyWhere(predicate) {\n        var _this28 = this;\n\n        return this.getNodesInternal().every(function (n, i) {\n          return predicate.call(_this28, _this28.wrap(n), i);\n        });\n      }\n\n      return everyWhere;\n    }()\n    /**\n     * Utility method used to create new wrappers with a mapping function that returns an array of\n     * nodes in response to a single node wrapper. The returned wrapper is a single wrapper around\n     * all of the mapped nodes flattened (and de-duplicated).\n     *\n     * @param {Function} fn\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'flatMap',\n    value: function () {\n      function flatMap(fn) {\n        var _this29 = this;\n\n        var nodes = this.getNodesInternal().map(function (n, i) {\n          return fn.call(_this29, _this29.wrap(n), i);\n        });\n        var flattened = (0, _arrayPrototype2['default'])(nodes, 1);\n        return this.wrap(flattened.filter(Boolean));\n      }\n\n      return flatMap;\n    }()\n    /**\n     * Finds all nodes in the current wrapper nodes' render trees that match the provided predicate\n     * function.\n     *\n     * @param {Function} predicate\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'findWhere',\n    value: function () {\n      function findWhere(predicate) {\n        var _this30 = this;\n\n        return findWhereUnwrapped(this, function (n) {\n          var node = _this30.wrap(n);\n\n          return node.length > 0 && predicate(node);\n        });\n      }\n\n      return findWhere;\n    }()\n    /**\n     * Returns the node at a given index of the current wrapper.\n     *\n     * @param {Number} index\n     * @returns {ReactElement}\n     */\n\n  }, {\n    key: 'get',\n    value: function () {\n      function get(index) {\n        return this.getElements()[index];\n      }\n\n      return get;\n    }()\n    /**\n     * Returns a wrapper around the node at a given index of the current wrapper.\n     *\n     * @param {Number} index\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'at',\n    value: function () {\n      function at(index) {\n        var nodes = this.getNodesInternal();\n\n        if (index < nodes.length) {\n          return this.wrap(nodes[index]);\n        }\n\n        return this.wrap([]);\n      }\n\n      return at;\n    }()\n    /**\n     * Returns a wrapper around the first node of the current wrapper.\n     *\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'first',\n    value: function () {\n      function first() {\n        return this.at(0);\n      }\n\n      return first;\n    }()\n    /**\n     * Returns a wrapper around the last node of the current wrapper.\n     *\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'last',\n    value: function () {\n      function last() {\n        return this.at(this.length - 1);\n      }\n\n      return last;\n    }()\n    /**\n     * Delegates to exists()\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    value: function () {\n      function isEmpty() {\n        // eslint-disable-next-line no-console\n        console.warn('Enzyme::Deprecated method isEmpty() called, use exists() instead.');\n        return !this.exists();\n      }\n\n      return isEmpty;\n    }()\n    /**\n     * Returns true if the current wrapper has nodes. False otherwise.\n     * If called with a selector it returns `.find(selector).exists()` instead.\n     *\n     * @param {EnzymeSelector} selector (optional)\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'exists',\n    value: function () {\n      function exists() {\n        var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        return arguments.length > 0 ? this.find(selector).exists() : this.length > 0;\n      }\n\n      return exists;\n    }()\n    /**\n     * Utility method that throws an error if the current instance has a length other than one.\n     * This is primarily used to enforce that certain methods are only run on a wrapper when it is\n     * wrapping a single node.\n     *\n     * @param {Function} fn\n     * @returns {*}\n     */\n\n  }, {\n    key: 'single',\n    value: function () {\n      function single(name, fn) {\n        var fnName = typeof name === 'string' ? name : 'unknown';\n        var callback = typeof fn === 'function' ? fn : name;\n\n        if (this.length !== 1) {\n          throw new Error('Method \\u201C' + fnName + '\\u201D is meant to be run on 1 node. ' + String(this.length) + ' found instead.');\n        }\n\n        return callback.call(this, this.getNodeInternal());\n      }\n\n      return single;\n    }()\n    /**\n     * Helpful utility method to create a new wrapper with the same root as the current wrapper, with\n     * any nodes passed in as the first parameter automatically wrapped.\n     *\n     * @param {ReactWrapper|ReactElement|Array<ReactElement>} node\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'wrap',\n    value: function () {\n      function wrap(node) {\n        var root = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this[ROOT];\n\n        if (node instanceof ReactWrapper) {\n          return node;\n        }\n\n        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n          args[_key2 - 2] = arguments[_key2];\n        }\n\n        return new (Function.prototype.bind.apply(ReactWrapper, [null].concat([node, root], args)))();\n      }\n\n      return wrap;\n    }()\n    /**\n     * Returns an HTML-like string of the shallow render for debugging purposes.\n     *\n     * @param {Object} [options] - Property bag of additional options.\n     * @param {boolean} [options.ignoreProps] - if true, props are omitted from the string.\n     * @param {boolean} [options.verbose] - if true, arrays and objects to be verbosely printed.\n     * @returns {String}\n     */\n\n  }, {\n    key: 'debug',\n    value: function () {\n      function debug() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return (0, _Debug.debugNodes)(this.getNodesInternal(), options);\n      }\n\n      return debug;\n    }()\n    /**\n     * Invokes intercepter and returns itself. intercepter is called with itself.\n     * This is helpful when debugging nodes in method chains.\n     * @param fn\n     * @returns {ReactWrapper}\n     */\n\n  }, {\n    key: 'tap',\n    value: function () {\n      function tap(intercepter) {\n        intercepter(this);\n        return this;\n      }\n\n      return tap;\n    }()\n    /**\n     * Detaches the react tree from the DOM. Runs `ReactDOM.unmountComponentAtNode()` under the hood.\n     *\n     * This method will most commonly be used as a \"cleanup\" method if you decide to use the\n     * `attachTo` option in `mount(node, options)`.\n     *\n     * The method is intentionally not \"fluent\" (in that it doesn't return `this`) because you should\n     * not be doing anything with this wrapper after this method is called.\n     */\n\n  }, {\n    key: 'detach',\n    value: function () {\n      function detach() {\n        if (this[ROOT] !== this) {\n          throw new Error('ReactWrapper::detach() can only be called on the root');\n        }\n\n        if (!this[OPTIONS].attachTo) {\n          throw new Error('ReactWrapper::detach() can only be called on when the `attachTo` option was passed into `mount()`.');\n        }\n\n        this[RENDERER].unmount();\n      }\n\n      return detach;\n    }()\n    /**\n     * Strips out all the not host-nodes from the list of nodes\n     *\n     * This method is useful if you want to check for the presence of host nodes\n     * (actually rendered HTML elements) ignoring the React nodes.\n     */\n\n  }, {\n    key: 'hostNodes',\n    value: function () {\n      function hostNodes() {\n        return this.filterWhere(function (n) {\n          return typeof n.type() === 'string';\n        });\n      }\n\n      return hostNodes;\n    }()\n  }]);\n\n  return ReactWrapper;\n}();\n/**\n * A *special* \"root\" wrapper that represents the component passed as `wrappingComponent`.\n * It is linked to the primary root such that updates to it will update the primary,\n * and vice versa.\n *\n * @class WrappingComponentWrapper\n */\n\n\nvar WrappingComponentWrapper = function (_ReactWrapper) {\n  _inherits(WrappingComponentWrapper, _ReactWrapper);\n  /* eslint-disable class-methods-use-this */\n\n\n  function WrappingComponentWrapper(root, renderer) {\n    _classCallCheck(this, WrappingComponentWrapper);\n\n    var _this31 = _possibleConstructorReturn(this, (WrappingComponentWrapper.__proto__ || Object.getPrototypeOf(WrappingComponentWrapper)).call(this, renderer.getNode(), root));\n\n    (0, _Utils.privateSet)(_this31, ROOT, _this31);\n    (0, _Utils.privateSet)(_this31, RENDERER, renderer);\n\n    _this31[LINKED_ROOTS].push(root);\n\n    return _this31;\n  }\n\n  _createClass(WrappingComponentWrapper, [{\n    key: 'getWrappingComponent',\n    value: function () {\n      function getWrappingComponent() {\n        throw new TypeError('ReactWrapper::getWrappingComponent() can only be called on the root');\n      }\n\n      return getWrappingComponent;\n    }()\n  }]);\n\n  return WrappingComponentWrapper;\n}(ReactWrapper);\n\nif (_Utils.ITERATOR_SYMBOL) {\n  Object.defineProperty(ReactWrapper.prototype, _Utils.ITERATOR_SYMBOL, {\n    configurable: true,\n    value: function () {\n      function iterator() {\n        var _ref;\n\n        var iter = this[NODES][_Utils.ITERATOR_SYMBOL]();\n\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n        return _ref = {}, _defineProperty(_ref, _Utils.ITERATOR_SYMBOL, function () {\n          return this;\n        }), _defineProperty(_ref, 'next', function () {\n          function next() {\n            var next = iter.next();\n\n            if (next.done) {\n              return {\n                done: true\n              };\n            }\n\n            return {\n              done: false,\n              value: adapter.nodeToElement(next.value)\n            };\n          }\n\n          return next;\n        }()), _ref;\n      }\n\n      return iterator;\n    }()\n  });\n}\n\nfunction privateWarning(prop, extraMessage) {\n  Object.defineProperty(ReactWrapper.prototype, prop, {\n    get: function () {\n      function get() {\n        throw new Error('\\n        Attempted to access ReactWrapper::' + String(prop) + ', which was previously a private property on\\n        Enzyme ReactWrapper instances, but is no longer and should not be relied upon.\\n        ' + String(extraMessage) + '\\n      ');\n      }\n\n      return get;\n    }(),\n    enumerable: false,\n    configurable: false\n  });\n}\n\nprivateWarning('node', 'Consider using the getElement() method instead.');\nprivateWarning('nodes', 'Consider using the getElements() method instead.');\nprivateWarning('renderer', '');\nprivateWarning('options', '');\nprivateWarning('complexSelector', '');\nexports['default'] = ReactWrapper; //# sourceMappingURL=ReactWrapper.js.map","map":{"version":3,"sources":["../src/ReactWrapper.js"],"names":["NODE","NODES","RENDERER","UNRENDERED","ROOT","OPTIONS","ROOT_NODES","WRAPPING_COMPONENT","LINKED_ROOTS","UPDATED_BY","filter","treeFilter","n","wrapper","getRootNodeInternal","Array","nodes","ReactWrapper","passedOptions","global","options","adapter","renderer","mode","privateSetNodes","root","refname","linkedRoot","props","callback","undefined","arguments","state","instance","context","nodeOrNodes","predicate","nodeEqual","findWhereUnwrapped","node","rstNode","a","selector","filterWhereUnwrapped","html","event","mock","error","thisNode","rootNode","nodeHierarchy","nodeParents","propsOfNode","name","_state","_context","allChildren","index","allParents","matchingAncestors","propName","handler","args","response","propValue","element","wrapped","className","console","fn","initialValue","i","begin","end","flattened","fnName","intercepter","WrappingComponentWrapper","ITERATOR_SYMBOL","Object","configurable","value","iter","next","done","get","enumerable","privateWarning"],"mappings":"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","sourcesContent":["import flat from 'array.prototype.flat';\nimport has from 'has';\n\nimport {\n  containsChildrenSubArray,\n  typeOfNode,\n  displayNameOfNode,\n  ITERATOR_SYMBOL,\n  nodeEqual,\n  nodeMatches,\n  makeOptions,\n  sym,\n  privateSet,\n  cloneElement,\n  renderedDive,\n  isCustomComponent,\n  loadCheerioRoot,\n} from './Utils';\nimport getAdapter from './getAdapter';\nimport { debugNodes } from './Debug';\nimport {\n  propsOfNode,\n  hasClassName,\n  childrenOfNode,\n  parentsOfNode,\n  treeFilter,\n  getTextFromHostNodes,\n  getHTMLFromHostNodes,\n} from './RSTTraversal';\n\nimport { buildPredicate, reduceTreesBySelector } from './selectors';\n\nconst NODE = sym('__node__');\nconst NODES = sym('__nodes__');\nconst RENDERER = sym('__renderer__');\nconst UNRENDERED = sym('__unrendered__');\nconst ROOT = sym('__root__');\nconst OPTIONS = sym('__options__');\nconst ROOT_NODES = sym('__rootNodes__');\nconst WRAPPING_COMPONENT = sym('__wrappingComponent__');\nconst LINKED_ROOTS = sym('__linkedRoots__');\nconst UPDATED_BY = sym('__updatedBy__');\n\n/**\n * Finds all nodes in the current wrapper nodes' render trees that match the provided predicate\n * function.\n *\n * @param {ReactWrapper} wrapper\n * @param {Function} predicate\n * @param {Function} filter\n * @returns {ReactWrapper}\n */\nfunction findWhereUnwrapped(wrapper, predicate, filter = treeFilter) {\n  return wrapper.flatMap((n) => filter(n.getNodeInternal(), predicate));\n}\n\n/**\n * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n * the provided predicate function.\n *\n * @param {ReactWrapper} wrapper\n * @param {Function} predicate\n * @returns {ReactWrapper}\n */\nfunction filterWhereUnwrapped(wrapper, predicate) {\n  return wrapper.wrap(wrapper.getNodesInternal().filter(predicate).filter(Boolean));\n}\n\nfunction getRootNodeInternal(wrapper) {\n  if (wrapper[ROOT].length !== 1) {\n    throw new Error('getRootNodeInternal(wrapper) can only be called when wrapper wraps one node');\n  }\n  if (wrapper[ROOT] !== wrapper) {\n    return wrapper[ROOT_NODES][0];\n  }\n  return wrapper[ROOT][NODE];\n}\n\nfunction nodeParents(wrapper, node) {\n  return parentsOfNode(node, getRootNodeInternal(wrapper));\n}\n\nfunction privateSetNodes(wrapper, nodes) {\n  if (!nodes) {\n    privateSet(wrapper, NODE, null);\n    privateSet(wrapper, NODES, []);\n  } else if (!Array.isArray(nodes)) {\n    privateSet(wrapper, NODE, nodes);\n    privateSet(wrapper, NODES, [nodes]);\n  } else {\n    privateSet(wrapper, NODE, nodes[0]);\n    privateSet(wrapper, NODES, nodes);\n  }\n  privateSet(wrapper, 'length', wrapper[NODES].length);\n}\n\n/**\n * @class ReactWrapper\n */\nclass ReactWrapper {\n  constructor(nodes, root, passedOptions = {}) {\n    if (!global.window && !global.document) {\n      throw new Error('It looks like you called `mount()` without a global document being loaded.');\n    }\n    const options = makeOptions(passedOptions);\n\n    if (!root) {\n      const adapter = getAdapter(options);\n      if (!adapter.isValidElement(nodes)) {\n        throw new TypeError('ReactWrapper can only wrap valid elements');\n      }\n\n      const renderer = adapter.createRenderer({ mode: 'mount', ...options });\n      privateSet(this, RENDERER, renderer);\n      renderer.render(nodes, options.context);\n      privateSet(this, ROOT, this);\n      privateSetNodes(this, this[RENDERER].getNode());\n      privateSet(this, OPTIONS, options);\n      privateSet(this, LINKED_ROOTS, []);\n\n      if (isCustomComponent(options.wrappingComponent, adapter)) {\n        if (typeof this[RENDERER].getWrappingComponentRenderer !== 'function') {\n          throw new TypeError('your adapter does not support `wrappingComponent`. Try upgrading it!');\n        }\n\n        // eslint-disable-next-line no-use-before-define\n        privateSet(this, WRAPPING_COMPONENT, new WrappingComponentWrapper(\n          this, this[RENDERER].getWrappingComponentRenderer(),\n        ));\n        this[LINKED_ROOTS].push(this[WRAPPING_COMPONENT]);\n      }\n    } else {\n      privateSet(this, RENDERER, root[RENDERER]);\n      privateSet(this, ROOT, root);\n      privateSetNodes(this, nodes);\n      privateSet(this, ROOT_NODES, root[NODES]);\n      privateSet(this, OPTIONS, root[OPTIONS]);\n      privateSet(this, LINKED_ROOTS, []);\n    }\n    privateSet(this, UNRENDERED, nodes);\n    privateSet(this, UPDATED_BY, null);\n  }\n\n  /**\n   * Returns the root wrapper\n   *\n   * @return {ReactWrapper}\n   */\n  root() {\n    return this[ROOT];\n  }\n\n  /**\n   * Returns the wrapped component.\n   *\n   * @return {ReactComponent}\n   */\n  getNodeInternal() {\n    if (this.length !== 1) {\n      throw new Error('ReactWrapper::getNode() can only be called when wrapping one node');\n    }\n    return this[NODES][0];\n  }\n\n  /**\n   * Returns the the wrapped components.\n   *\n   * @return {Array<ReactComponent>}\n   */\n  getNodesInternal() {\n    return this[NODES];\n  }\n\n  /**\n   * Returns the wrapped ReactElement.\n   *\n   * @return {ReactElement}\n   */\n  getElement() {\n    return this.single('getElement', () => getAdapter(this[OPTIONS]).nodeToElement(this[NODE]));\n  }\n\n  /**\n   * Returns the wrapped ReactElements.\n   *\n   * @return {Array<ReactElement>}\n   */\n  getElements() {\n    return this[NODES].map((n) => getAdapter(this[OPTIONS]).nodeToElement(n));\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  getNode() {\n    throw new Error('ReactWrapper::getNode() is no longer supported. Use ReactWrapper::instance() instead');\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  getNodes() {\n    throw new Error('ReactWrapper::getNodes() is no longer supported.');\n  }\n\n  /**\n   * Returns the outer most DOMComponent of the current wrapper.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {DOMComponent}\n   */\n  getDOMNode() {\n    const adapter = getAdapter(this[OPTIONS]);\n    return this.single('getDOMNode', (n) => adapter.nodeToHostNode(n, true));\n  }\n\n  /**\n   * If the root component contained a ref, you can access it here and get the relevant\n   * react component instance or HTML element instance.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @param {String} refname\n   * @returns {ReactComponent | HTMLElement}\n   */\n  ref(refname) {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::ref(refname) can only be called on the root');\n    }\n    return this.instance().refs[refname];\n  }\n\n  /**\n   * Returns the wrapper's underlying instance.\n   *\n   * Example:\n   * ```\n   * const wrapper = mount(<MyComponent />);\n   * const inst = wrapper.instance();\n   * expect(inst).to.be.instanceOf(MyComponent);\n   * ```\n   * @returns {ReactComponent|DOMComponent}\n   */\n  instance() {\n    return this.single('instance', () => this[NODE].instance);\n  }\n\n  /**\n   * If a `wrappingComponent` was passed in `options`, this methods returns a `ReactWrapper` around\n   * the rendered `wrappingComponent`. This `ReactWrapper` can be used to update the\n   * `wrappingComponent`'s props, state, etc.\n   *\n   * @returns ReactWrapper\n   */\n  getWrappingComponent() {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::getWrappingComponent() can only be called on the root');\n    }\n    if (!this[OPTIONS].wrappingComponent) {\n      throw new Error('ReactWrapper::getWrappingComponent() can only be called on a wrapper that was originally passed a `wrappingComponent` option');\n    }\n    return this[WRAPPING_COMPONENT];\n  }\n\n  /**\n   * Forces a re-render. Useful to run before checking the render output if something external\n   * may be updating the state of the component somewhere.\n   *\n   * NOTE: no matter what instance this is called on, it will always update the root.\n   *\n   * @returns {ReactWrapper}\n   */\n  update() {\n    const root = this[ROOT];\n    if (this !== root) {\n      return root.update();\n    }\n    privateSetNodes(this, this[RENDERER].getNode());\n    this[LINKED_ROOTS].forEach((linkedRoot) => {\n      if (linkedRoot !== this[UPDATED_BY]) {\n        /* eslint-disable no-param-reassign */\n        // Only update a linked it root if it is not the originator of our update().\n        // This is needed to prevent infinite recursion when there is a bi-directional\n        // link between two roots.\n        linkedRoot[UPDATED_BY] = this;\n        try {\n          linkedRoot.update();\n        } finally {\n          linkedRoot[UPDATED_BY] = null;\n        }\n      }\n    });\n    return this;\n  }\n\n  /**\n   * A method that unmounts the component. This can be used to simulate a component going through\n   * and unmount/mount lifecycle.\n   *\n   * @returns {ReactWrapper}\n   */\n  unmount() {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::unmount() can only be called on the root');\n    }\n    this.single('unmount', () => {\n      this[RENDERER].unmount();\n      this.update();\n    });\n    return this;\n  }\n\n  /**\n   * A method that re-mounts the component, if it is not currently mounted.\n   * This can be used to simulate a component going through\n   * an unmount/mount lifecycle.\n   *\n   * @returns {ReactWrapper}\n   */\n  mount() {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::mount() can only be called on the root');\n    }\n    this[RENDERER].render(this[UNRENDERED], this[OPTIONS].context, () => this.update());\n    return this;\n  }\n\n  /**\n   * A method that sets the props of the root component, and re-renders. Useful for when you are\n   * wanting to test how the component behaves over time with changing props. Calling this, for\n   * instance, will call the `componentWillReceiveProps` lifecycle method.\n   *\n   * Similar to `setState`, this method accepts a props object and will merge it in with the already\n   * existing props.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @param {Object} props object\n   * @param {Function} cb - callback function\n   * @returns {ReactWrapper}\n   */\n  setProps(props, callback = undefined) {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::setProps() can only be called on the root');\n    }\n    if (arguments.length > 1 && typeof callback !== 'function') {\n      throw new TypeError('ReactWrapper::setProps() expects a function as its second argument');\n    }\n    const adapter = getAdapter(this[OPTIONS]);\n    this[UNRENDERED] = cloneElement(adapter, this[UNRENDERED], props);\n    this[RENDERER].render(this[UNRENDERED], null, () => {\n      this.update();\n      if (callback) {\n        callback();\n      }\n    });\n    return this;\n  }\n\n  /**\n   * A method to invoke `setState` on the root component instance similar to how you might in the\n   * definition of the component, and re-renders.  This method is useful for testing your component\n   * in hard to achieve states, however should be used sparingly. If possible, you should utilize\n   * your component's external API in order to get it into whatever state you want to test, in order\n   * to be as accurate of a test as possible. This is not always practical, however.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @param {Object} state to merge\n   * @param {Function} cb - callback function\n   * @returns {ReactWrapper}\n   */\n  setState(state, callback = undefined) {\n    if (this.instance() === null || this.getNodeInternal().nodeType !== 'class') {\n      throw new Error('ReactWrapper::setState() can only be called on class components');\n    }\n    if (arguments.length > 1 && typeof callback !== 'function') {\n      throw new TypeError('ReactWrapper::setState() expects a function as its second argument');\n    }\n    this.instance().setState(state, () => {\n      this.update();\n      if (callback) {\n        const adapter = getAdapter(this[OPTIONS]);\n        const instance = this.instance();\n        if (adapter.invokeSetStateCallback) {\n          adapter.invokeSetStateCallback(instance, callback);\n        } else {\n          callback.call(instance);\n        }\n      }\n    });\n    return this;\n  }\n\n  /**\n   * A method that sets the context of the root component, and re-renders. Useful for when you are\n   * wanting to test how the component behaves over time with changing contexts.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @param {Object} context object\n   * @returns {ReactWrapper}\n   */\n  setContext(context) {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::setContext() can only be called on the root');\n    }\n    if (!this[OPTIONS].context) {\n      throw new Error('ReactWrapper::setContext() can only be called on a wrapper that was originally passed a context option');\n    }\n    this[RENDERER].render(this[UNRENDERED], context, () => this.update());\n    return this;\n  }\n\n  /**\n   * Whether or not a given react element exists in the mount render tree.\n   *\n   * Example:\n   * ```\n   * const wrapper = mount(<MyComponent />);\n   * expect(wrapper.contains(<div className=\"foo bar\" />)).to.equal(true);\n   * ```\n   *\n   * @param {ReactElement|Array<ReactElement>} nodeOrNodes\n   * @returns {Boolean}\n   */\n  contains(nodeOrNodes) {\n    const adapter = getAdapter(this[OPTIONS]);\n\n    const predicate = Array.isArray(nodeOrNodes)\n      ? (other) => containsChildrenSubArray(\n        nodeEqual,\n        other,\n        nodeOrNodes.map((node) => adapter.elementToNode(node)),\n      )\n      : (other) => nodeEqual(adapter.elementToNode(nodeOrNodes), other);\n\n    return findWhereUnwrapped(this, predicate).length > 0;\n  }\n\n  /**\n   * Whether or not a given react element exists in the current render tree.\n   * It will determine if one of the wrappers element \"looks like\" the expected\n   * element by checking if all props of the expected element are present\n   * on the wrappers element and equals to each other.\n   *\n   * Example:\n   * ```\n   * // MyComponent outputs <div><div class=\"foo\">Hello</div></div>\n   * const wrapper = mount(<MyComponent />);\n   * expect(wrapper.containsMatchingElement(<div>Hello</div>)).to.equal(true);\n   * ```\n   *\n   * @param {ReactElement} node\n   * @returns {Boolean}\n   */\n  containsMatchingElement(node) {\n    const rstNode = getAdapter(this[OPTIONS]).elementToNode(node);\n    const predicate = (other) => nodeMatches(rstNode, other, (a, b) => a <= b);\n    return findWhereUnwrapped(this, predicate).length > 0;\n  }\n\n  /**\n   * Whether or not all the given react elements exist in the current render tree.\n   * It will determine if one of the wrappers element \"looks like\" the expected\n   * element by checking if all props of the expected element are present\n   * on the wrappers element and equals to each other.\n   *\n   * Example:\n   * ```\n   * const wrapper = mount(<MyComponent />);\n   * expect(wrapper.containsAllMatchingElements([\n   *   <div>Hello</div>,\n   *   <div>Goodbye</div>,\n   * ])).to.equal(true);\n   * ```\n   *\n   * @param {Array<ReactElement>} nodes\n   * @returns {Boolean}\n   */\n  containsAllMatchingElements(nodes) {\n    if (!Array.isArray(nodes)) {\n      throw new TypeError('nodes should be an Array');\n    }\n\n    return nodes.every((node) => this.containsMatchingElement(node));\n  }\n\n  /**\n   * Whether or not one of the given react elements exists in the current render tree.\n   * It will determine if one of the wrappers element \"looks like\" the expected\n   * element by checking if all props of the expected element are present\n   * on the wrappers element and equals to each other.\n   *\n   * Example:\n   * ```\n   * const wrapper = mount(<MyComponent />);\n   * expect(wrapper.containsAnyMatchingElements([\n   *   <div>Hello</div>,\n   *   <div>Goodbye</div>,\n   * ])).to.equal(true);\n   * ```\n   *\n   * @param {Array<ReactElement>} nodes\n   * @returns {Boolean}\n   */\n  containsAnyMatchingElements(nodes) {\n    return Array.isArray(nodes) && nodes.some((node) => this.containsMatchingElement(node));\n  }\n\n  /**\n   * Whether or not a given react element exists in the render tree.\n   *\n   * Example:\n   * ```\n   * const wrapper = mount(<MyComponent />);\n   * expect(wrapper.contains(<div className=\"foo bar\" />)).to.equal(true);\n   * ```\n   *\n   * @param {ReactElement} node\n   * @returns {Boolean}\n   */\n  equals(node) {\n    return this.single('equals', () => nodeEqual(this.getNodeInternal(), node));\n  }\n\n  /**\n   * Whether or not a given react element matches the render tree.\n   * Match is based on the expected element and not on wrapper root node.\n   * It will determine if the wrapper root node \"looks like\" the expected\n   * element by checking if all props of the expected element are present\n   * on the wrapper root node and equals to each other.\n   *\n   * Example:\n   * ```\n   * // MyComponent outputs <div class=\"foo\">Hello</div>\n   * const wrapper = mount(<MyComponent />);\n   * expect(wrapper.matchesElement(<div>Hello</div>)).to.equal(true);\n   * ```\n   *\n   * @param {ReactElement} node\n   * @returns {Boolean}\n   */\n  matchesElement(node) {\n    return this.single('matchesElement', () => {\n      const adapter = getAdapter(this[OPTIONS]);\n      const rstNode = adapter.elementToNode(node);\n      return nodeMatches(rstNode, this.getNodeInternal(), (a, b) => a <= b);\n    });\n  }\n\n  /**\n   * Finds every node in the render tree of the current wrapper that matches the provided selector.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {ReactWrapper}\n   */\n  find(selector) {\n    return this.wrap(reduceTreesBySelector(selector, this.getNodesInternal()));\n  }\n\n  /**\n   * Returns whether or not current node matches a provided selector.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {boolean}\n   */\n  is(selector) {\n    const predicate = buildPredicate(selector);\n    return this.single('is', (n) => predicate(n));\n  }\n\n  /**\n   * Returns true if the component rendered nothing, i.e., null or false.\n   *\n   * @returns {boolean}\n   */\n  isEmptyRender() {\n    const nodes = this.getNodeInternal();\n\n    return renderedDive(nodes);\n  }\n\n  /**\n   * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n   * the provided predicate function.\n   *\n   * @param {Function} predicate\n   * @returns {ReactWrapper}\n   */\n  filterWhere(predicate) {\n    return filterWhereUnwrapped(this, (n) => predicate(this.wrap(n)));\n  }\n\n  /**\n   * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n   * the provided selector.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {ReactWrapper}\n   */\n  filter(selector) {\n    const predicate = buildPredicate(selector);\n    return filterWhereUnwrapped(this, predicate);\n  }\n\n  /**\n   * Returns a new wrapper instance with only the nodes of the current wrapper that did not match\n   * the provided selector. Essentially the inverse of `filter`.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {ReactWrapper}\n   */\n  not(selector) {\n    const predicate = buildPredicate(selector);\n    return filterWhereUnwrapped(this, (n) => !predicate(n));\n  }\n\n  /**\n   * Returns a string of the rendered text of the current render tree.  This function should be\n   * looked at with skepticism if being used to test what the actual HTML output of the component\n   * will be. If that is what you would like to test, use enzyme's `render` function instead.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {String}\n   */\n  text() {\n    const adapter = getAdapter(this[OPTIONS]);\n    return this.single('text', (n) => getTextFromHostNodes(n, adapter));\n  }\n\n  /**\n   * Returns the HTML of the node.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {String}\n   */\n  html() {\n    const adapter = getAdapter(this[OPTIONS]);\n    return this.single('html', (n) => getHTMLFromHostNodes(n, adapter));\n  }\n\n  /**\n   * Returns the current node rendered to HTML and wrapped in a CheerioWrapper.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {CheerioWrapper}\n   */\n  render() {\n    const html = this.html();\n    return loadCheerioRoot(html);\n  }\n\n  /**\n   * Used to simulate events. Pass an eventname and (optionally) event arguments. This method of\n   * testing events should be met with some skepticism.\n   *\n   * @param {String} event\n   * @param {Object} mock (optional)\n   * @returns {ReactWrapper}\n   */\n  simulate(event, mock = {}) {\n    return this.single('simulate', (n) => {\n      this[RENDERER].simulateEvent(n, event, mock);\n      this[ROOT].update();\n      return this;\n    });\n  }\n\n  /**\n   * Used to simulate throwing a rendering error. Pass an error to throw.\n   *\n   * @param {String} error\n   * @returns {ReactWrapper}\n   */\n  simulateError(error) {\n    if (this[ROOT] === this) {\n      throw new Error('ReactWrapper::simulateError() may not be called on the root');\n    }\n\n    return this.single('simulateError', (thisNode) => {\n      if (thisNode.nodeType === 'host') {\n        throw new Error('ReactWrapper::simulateError() can only be called on custom components');\n      }\n\n      const renderer = this[RENDERER];\n      if (typeof renderer.simulateError !== 'function') {\n        throw new TypeError('your adapter does not support `simulateError`. Try upgrading it!');\n      }\n\n      const rootNode = getRootNodeInternal(this);\n      const nodeHierarchy = [thisNode].concat(nodeParents(this, thisNode));\n      renderer.simulateError(nodeHierarchy, rootNode, error);\n\n      this[ROOT].update();\n      return this;\n    });\n  }\n\n  /**\n   * Returns the props hash for the root node of the wrapper.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {Object}\n   */\n  props() {\n    return this.single('props', propsOfNode);\n  }\n\n  /**\n   * Returns the state hash for the root node of the wrapper. Optionally pass in a prop name and it\n   * will return just that value.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {String} name (optional)\n   * @returns {*}\n   */\n  state(name) {\n    const thisNode = this[ROOT] === this ? this[RENDERER].getNode() : this.getNodeInternal();\n    if (this.instance() === null || thisNode.nodeType !== 'class') {\n      throw new Error('ReactWrapper::state() can only be called on class components');\n    }\n    const _state = this.single('state', () => this.instance().state);\n    if (typeof name !== 'undefined') {\n      if (_state == null) {\n        throw new TypeError(`ReactWrapper::state(\"${name}\") requires that \\`state\\` not be \\`null\\` or \\`undefined\\``);\n      }\n      return _state[name];\n    }\n    return _state;\n  }\n\n  /**\n   * Returns the context hash for the root node of the wrapper.\n   * Optionally pass in a prop name and it will return just that value.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {String} name (optional)\n   * @returns {*}\n   */\n  context(name) {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::context() can only be called on the root');\n    }\n    const instance = this.single('context', () => this.instance());\n    if (instance === null) {\n      throw new Error('ReactWrapper::context() can only be called on components with instances');\n    }\n    const _context = instance.context;\n    if (typeof name !== 'undefined') {\n      return _context[name];\n    }\n    return _context;\n  }\n\n  /**\n   * Returns a new wrapper with all of the children of the current wrapper.\n   *\n   * @param {EnzymeSelector} [selector]\n   * @returns {ReactWrapper}\n   */\n  children(selector) {\n    const allChildren = this.flatMap((n) => childrenOfNode(n.getNodeInternal()));\n    return selector ? allChildren.filter(selector) : allChildren;\n  }\n\n  /**\n   * Returns a new wrapper with a specific child\n   *\n   * @param {Number} [index]\n   * @returns {ReactWrapper}\n   */\n  childAt(index) {\n    return this.single('childAt', () => this.children().at(index));\n  }\n\n  /**\n   * Returns a wrapper around all of the parents/ancestors of the wrapper. Does not include the node\n   * in the current wrapper.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {EnzymeSelector} [selector]\n   * @returns {ReactWrapper}\n   */\n  parents(selector) {\n    return this.single('parents', (n) => {\n      const allParents = this.wrap(nodeParents(this, n));\n      return selector ? allParents.filter(selector) : allParents;\n    });\n  }\n\n  /**\n   * Returns a wrapper around the immediate parent of the current node.\n   *\n   * @returns {ReactWrapper}\n   */\n  parent() {\n    return this.flatMap((n) => [n.parents().get(0)]);\n  }\n\n  /**\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {ReactWrapper}\n   */\n  closest(selector) {\n    if (this.is(selector)) {\n      return this;\n    }\n    const matchingAncestors = this.parents().filter(selector);\n    return matchingAncestors.length > 0 ? matchingAncestors.first() : this.findWhere(() => false);\n  }\n\n  /**\n   * Returns the value of  prop with the given name of the root node.\n   *\n   * @param {String} propName\n   * @returns {*}\n   */\n  prop(propName) {\n    return this.props()[propName];\n  }\n\n  /**\n   * Used to invoke a function prop.\n   * Will invoke an function prop and return its value.\n   *\n   * @param {String} propName\n   * @returns {Any}\n   */\n  invoke(propName) {\n    return this.single('invoke', () => {\n      const handler = this.prop(propName);\n      if (typeof handler !== 'function') {\n        throw new TypeError('ReactWrapper::invoke() requires the name of a prop whose value is a function');\n      }\n      return (...args) => {\n        const response = typeof this[RENDERER].wrapInvoke === 'function'\n          ? this[RENDERER].wrapInvoke(() => handler(...args))\n          : handler(...args);\n        this[ROOT].update();\n        return response;\n      };\n    });\n  }\n\n  /**\n   * Returns a wrapper of the node rendered by the provided render prop.\n   *\n   * @param {String} propName\n   * @returns {Function}\n   */\n  renderProp(propName) {\n    const adapter = getAdapter(this[OPTIONS]);\n    if (typeof adapter.wrap !== 'function') {\n      throw new RangeError('your adapter does not support `wrap`. Try upgrading it!');\n    }\n\n    return this.single('renderProp', (n) => {\n      if (n.nodeType === 'host') {\n        throw new TypeError('ReactWrapper::renderProp() can only be called on custom components');\n      }\n      if (typeof propName !== 'string') {\n        throw new TypeError('ReactWrapper::renderProp(): `propName` must be a string');\n      }\n      const props = this.props();\n      if (!has(props, propName)) {\n        throw new Error(`ReactWrapper::renderProp(): no prop called ${propName} found`);\n      }\n      const propValue = props[propName];\n      if (typeof propValue !== 'function') {\n        throw new TypeError(`ReactWrapper::renderProp(): expected prop ${propName} to contain a function, but it holds ${typeof propValue}`);\n      }\n\n      return (...args) => {\n        const element = propValue(...args);\n        const wrapped = adapter.wrap(element);\n        return this.wrap(wrapped, null, this[OPTIONS]);\n      };\n    });\n  }\n\n  /**\n   * Returns the key assigned to the current node.\n   *\n   * @returns {String}\n   */\n  key() {\n    return this.single('key', (n) => (n.key === undefined ? null : n.key));\n  }\n\n  /**\n   * Returns the type of the root node of this wrapper. If it's a composite component, this will be\n   * the component constructor. If it's native DOM node, it will be a string.\n   *\n   * @returns {String|Function}\n   */\n  type() {\n    return this.single('type', (n) => typeOfNode(n));\n  }\n\n  /**\n   * Returns the name of the root node of this wrapper.\n   *\n   * In order of precedence => type.displayName -> type.name -> type.\n   *\n   * @returns {String}\n   */\n  name() {\n    const adapter = getAdapter(this[OPTIONS]);\n    return this.single('name', (n) => (\n      adapter.displayNameOfNode ? adapter.displayNameOfNode(n) : displayNameOfNode(n)\n    ));\n  }\n\n  /**\n   * Returns whether or not the current root node has the given class name or not.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {String} className\n   * @returns {Boolean}\n   */\n  hasClass(className) {\n    if (typeof className === 'string' && className.indexOf('.') !== -1) {\n      // eslint-disable-next-line no-console\n      console.warn('It looks like you\\'re calling `ReactWrapper::hasClass()` with a CSS selector. hasClass() expects a class name, not a CSS selector.');\n    }\n    return this.single('hasClass', (n) => hasClassName(n, className));\n  }\n\n  /**\n   * Iterates through each node of the current wrapper and executes the provided function with a\n   * wrapper around the corresponding node passed in as the first argument.\n   *\n   * @param {Function} fn\n   * @returns {ReactWrapper}\n   */\n  forEach(fn) {\n    this.getNodesInternal().forEach((n, i) => fn.call(this, this.wrap(n), i));\n    return this;\n  }\n\n  /**\n   * Maps the current array of nodes to another array. Each node is passed in as a `ReactWrapper`\n   * to the map function.\n   *\n   * @param {Function} fn\n   * @returns {Array}\n   */\n  map(fn) {\n    return this.getNodesInternal().map((n, i) => fn.call(this, this.wrap(n), i));\n  }\n\n  /**\n   * Reduces the current array of nodes to another array.\n   * Each node is passed in as a `ShallowWrapper` to the reducer function.\n   *\n   * @param {Function} fn - the reducer function\n   * @param {*} initialValue - the initial value\n   * @returns {*}\n   */\n  reduce(fn, initialValue = undefined) {\n    if (arguments.length > 1) {\n      return this.getNodesInternal().reduce(\n        (accum, n, i) => fn.call(this, accum, this.wrap(n), i),\n        initialValue,\n      );\n    }\n    return this.getNodesInternal().reduce((accum, n, i) => fn.call(\n      this,\n      i === 1 ? this.wrap(accum) : accum,\n      this.wrap(n),\n      i,\n    ));\n  }\n\n  /**\n   * Reduces the current array of nodes to another array, from right to left. Each node is passed\n   * in as a `ShallowWrapper` to the reducer function.\n   *\n   * @param {Function} fn - the reducer function\n   * @param {*} initialValue - the initial value\n   * @returns {*}\n   */\n  reduceRight(fn, initialValue = undefined) {\n    if (arguments.length > 1) {\n      return this.getNodesInternal().reduceRight(\n        (accum, n, i) => fn.call(this, accum, this.wrap(n), i),\n        initialValue,\n      );\n    }\n    return this.getNodesInternal().reduceRight((accum, n, i) => fn.call(\n      this,\n      i === 1 ? this.wrap(accum) : accum,\n      this.wrap(n),\n      i,\n    ));\n  }\n\n  /**\n   * Returns a new wrapper with a subset of the nodes of the original wrapper, according to the\n   * rules of `Array#slice`.\n   *\n   * @param {Number} begin\n   * @param {Number} end\n   * @returns {ShallowWrapper}\n   */\n  slice(begin, end) {\n    return this.wrap(this.getNodesInternal().slice(begin, end));\n  }\n\n  /**\n   * Returns whether or not any of the nodes in the wrapper match the provided selector.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {Boolean}\n   */\n  some(selector) {\n    if (this[ROOT] === this) {\n      throw new Error('ReactWrapper::some() can not be called on the root');\n    }\n    const predicate = buildPredicate(selector);\n    return this.getNodesInternal().some(predicate);\n  }\n\n  /**\n   * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.\n   *\n   * @param {Function} predicate\n   * @returns {Boolean}\n   */\n  someWhere(predicate) {\n    return this.getNodesInternal().some((n, i) => predicate.call(this, this.wrap(n), i));\n  }\n\n  /**\n   * Returns whether or not all of the nodes in the wrapper match the provided selector.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {Boolean}\n   */\n  every(selector) {\n    const predicate = buildPredicate(selector);\n    return this.getNodesInternal().every(predicate);\n  }\n\n  /**\n   * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.\n   *\n   * @param {Function} predicate\n   * @returns {Boolean}\n   */\n  everyWhere(predicate) {\n    return this.getNodesInternal().every((n, i) => predicate.call(this, this.wrap(n), i));\n  }\n\n  /**\n   * Utility method used to create new wrappers with a mapping function that returns an array of\n   * nodes in response to a single node wrapper. The returned wrapper is a single wrapper around\n   * all of the mapped nodes flattened (and de-duplicated).\n   *\n   * @param {Function} fn\n   * @returns {ReactWrapper}\n   */\n  flatMap(fn) {\n    const nodes = this.getNodesInternal().map((n, i) => fn.call(this, this.wrap(n), i));\n    const flattened = flat(nodes, 1);\n    return this.wrap(flattened.filter(Boolean));\n  }\n\n  /**\n   * Finds all nodes in the current wrapper nodes' render trees that match the provided predicate\n   * function.\n   *\n   * @param {Function} predicate\n   * @returns {ReactWrapper}\n   */\n  findWhere(predicate) {\n    return findWhereUnwrapped(this, (n) => {\n      const node = this.wrap(n);\n      return node.length > 0 && predicate(node);\n    });\n  }\n\n  /**\n   * Returns the node at a given index of the current wrapper.\n   *\n   * @param {Number} index\n   * @returns {ReactElement}\n   */\n  get(index) {\n    return this.getElements()[index];\n  }\n\n  /**\n   * Returns a wrapper around the node at a given index of the current wrapper.\n   *\n   * @param {Number} index\n   * @returns {ReactWrapper}\n   */\n  at(index) {\n    const nodes = this.getNodesInternal();\n    if (index < nodes.length) {\n      return this.wrap(nodes[index]);\n    }\n    return this.wrap([]);\n  }\n\n  /**\n   * Returns a wrapper around the first node of the current wrapper.\n   *\n   * @returns {ReactWrapper}\n   */\n  first() {\n    return this.at(0);\n  }\n\n  /**\n   * Returns a wrapper around the last node of the current wrapper.\n   *\n   * @returns {ReactWrapper}\n   */\n  last() {\n    return this.at(this.length - 1);\n  }\n\n  /**\n   * Delegates to exists()\n   *\n   * @returns {boolean}\n   */\n  isEmpty() {\n    // eslint-disable-next-line no-console\n    console.warn('Enzyme::Deprecated method isEmpty() called, use exists() instead.');\n    return !this.exists();\n  }\n\n  /**\n   * Returns true if the current wrapper has nodes. False otherwise.\n   * If called with a selector it returns `.find(selector).exists()` instead.\n   *\n   * @param {EnzymeSelector} selector (optional)\n   * @returns {boolean}\n   */\n  exists(selector = null) {\n    return arguments.length > 0 ? this.find(selector).exists() : this.length > 0;\n  }\n\n  /**\n   * Utility method that throws an error if the current instance has a length other than one.\n   * This is primarily used to enforce that certain methods are only run on a wrapper when it is\n   * wrapping a single node.\n   *\n   * @param {Function} fn\n   * @returns {*}\n   */\n  single(name, fn) {\n    const fnName = typeof name === 'string' ? name : 'unknown';\n    const callback = typeof fn === 'function' ? fn : name;\n    if (this.length !== 1) {\n      throw new Error(`Method ${fnName} is meant to be run on 1 node. ${this.length} found instead.`);\n    }\n    return callback.call(this, this.getNodeInternal());\n  }\n\n  /**\n   * Helpful utility method to create a new wrapper with the same root as the current wrapper, with\n   * any nodes passed in as the first parameter automatically wrapped.\n   *\n   * @param {ReactWrapper|ReactElement|Array<ReactElement>} node\n   * @returns {ReactWrapper}\n   */\n  wrap(node, root = this[ROOT], ...args) {\n    if (node instanceof ReactWrapper) {\n      return node;\n    }\n    return new ReactWrapper(node, root, ...args);\n  }\n\n  /**\n   * Returns an HTML-like string of the shallow render for debugging purposes.\n   *\n   * @param {Object} [options] - Property bag of additional options.\n   * @param {boolean} [options.ignoreProps] - if true, props are omitted from the string.\n   * @param {boolean} [options.verbose] - if true, arrays and objects to be verbosely printed.\n   * @returns {String}\n   */\n  debug(options = {}) {\n    return debugNodes(this.getNodesInternal(), options);\n  }\n\n  /**\n   * Invokes intercepter and returns itself. intercepter is called with itself.\n   * This is helpful when debugging nodes in method chains.\n   * @param fn\n   * @returns {ReactWrapper}\n   */\n  tap(intercepter) {\n    intercepter(this);\n    return this;\n  }\n\n  /**\n   * Detaches the react tree from the DOM. Runs `ReactDOM.unmountComponentAtNode()` under the hood.\n   *\n   * This method will most commonly be used as a \"cleanup\" method if you decide to use the\n   * `attachTo` option in `mount(node, options)`.\n   *\n   * The method is intentionally not \"fluent\" (in that it doesn't return `this`) because you should\n   * not be doing anything with this wrapper after this method is called.\n   */\n  detach() {\n    if (this[ROOT] !== this) {\n      throw new Error('ReactWrapper::detach() can only be called on the root');\n    }\n    if (!this[OPTIONS].attachTo) {\n      throw new Error('ReactWrapper::detach() can only be called on when the `attachTo` option was passed into `mount()`.');\n    }\n    this[RENDERER].unmount();\n  }\n\n  /**\n   * Strips out all the not host-nodes from the list of nodes\n   *\n   * This method is useful if you want to check for the presence of host nodes\n   * (actually rendered HTML elements) ignoring the React nodes.\n   */\n  hostNodes() {\n    return this.filterWhere((n) => typeof n.type() === 'string');\n  }\n}\n\n/**\n * A *special* \"root\" wrapper that represents the component passed as `wrappingComponent`.\n * It is linked to the primary root such that updates to it will update the primary,\n * and vice versa.\n *\n * @class WrappingComponentWrapper\n */\nclass WrappingComponentWrapper extends ReactWrapper {\n  /* eslint-disable class-methods-use-this */\n  constructor(root, renderer) {\n    super(renderer.getNode(), root);\n\n    privateSet(this, ROOT, this);\n    privateSet(this, RENDERER, renderer);\n    this[LINKED_ROOTS].push(root);\n  }\n\n  getWrappingComponent() {\n    throw new TypeError('ReactWrapper::getWrappingComponent() can only be called on the root');\n  }\n}\n\nif (ITERATOR_SYMBOL) {\n  Object.defineProperty(ReactWrapper.prototype, ITERATOR_SYMBOL, {\n    configurable: true,\n    value: function iterator() {\n      const iter = this[NODES][ITERATOR_SYMBOL]();\n      const adapter = getAdapter(this[OPTIONS]);\n      return {\n        [ITERATOR_SYMBOL]() { return this; },\n        next() {\n          const next = iter.next();\n          if (next.done) {\n            return { done: true };\n          }\n          return {\n            done: false,\n            value: adapter.nodeToElement(next.value),\n          };\n        },\n      };\n    },\n  });\n}\n\nfunction privateWarning(prop, extraMessage) {\n  Object.defineProperty(ReactWrapper.prototype, prop, {\n    get() {\n      throw new Error(`\n        Attempted to access ReactWrapper::${prop}, which was previously a private property on\n        Enzyme ReactWrapper instances, but is no longer and should not be relied upon.\n        ${extraMessage}\n      `);\n    },\n    enumerable: false,\n    configurable: false,\n  });\n}\n\nprivateWarning('node', 'Consider using the getElement() method instead.');\nprivateWarning('nodes', 'Consider using the getElements() method instead.');\nprivateWarning('renderer', '');\nprivateWarning('options', '');\nprivateWarning('complexSelector', '');\n\nexport default ReactWrapper;\n"]},"metadata":{},"sourceType":"script"}