{"ast":null,"code":"/* jshint node:true */\n'use strict';\n\nconst Transform = require('stream').Transform;\n\nclass Stream extends Transform {\n  constructor(parser) {\n    super();\n    this._parser = parser;\n    this._options = parser._options;\n    this._headers = this._options.headers || [];\n    this._hasHeaders = false;\n    this._lastError = null;\n  }\n\n  _mergeChunk(chunk) {\n    let self = this;\n    self._extra = self._extra || \"\"; // Remove starting comma\n\n    if (self._extra.charAt(0) == ',') self._extra = self._extra.substr(1); // Append extra to chunk\n\n    chunk = self._extra + chunk.toString(); // Clear extra memory\n\n    if (self._extra.length > 0) self._extra = \"\";\n    return chunk;\n  }\n\n  _wrapArray(data) {\n    if (data.charAt(0) != '[') data = '[' + data;\n    if (data.charAt(data.length - 1) != ']') data += ']';\n    return data;\n  }\n\n  _transform(chunk, encoding, done) {\n    let self = this;\n    let json = null; // Append extra data to chunk data\n\n    chunk = this._mergeChunk(chunk);\n    if (!chunk) return done(this._lastError); // Split chunk in objects\n\n    let parts = chunk.split('}');\n\n    while (json === null && parts.length > 0) {\n      try {\n        let data = self._wrapArray(parts.join('}'));\n\n        json = JSON.parse(data);\n      } catch (ex) {\n        this._lastError = ex;\n        let extraChunk = parts.pop();\n        self._extra = extraChunk + (self._extra || \"\");\n        if (parts.length > 0) parts[parts.length - 1] += \"}\";\n      }\n    }\n\n    if (!json) return done();\n\n    this._parser.parse(json, (err, csvChunk) => {\n      if (err) return done(err);\n\n      if (!self.hasHeaders) {\n        self.hasHeaders = true;\n        self.push(self._parser.headers);\n      }\n\n      self.push(self._options.endOfLine + csvChunk);\n      done();\n    }, true);\n  }\n\n}\n\nmodule.exports = Stream;","map":{"version":3,"sources":["C:/Users/User/Documents/Projects/AirQo-frontend/locate/node_modules/jsonexport/lib/core/stream.js"],"names":["Transform","require","Stream","constructor","parser","_parser","_options","_headers","headers","_hasHeaders","_lastError","_mergeChunk","chunk","self","_extra","charAt","substr","toString","length","_wrapArray","data","_transform","encoding","done","json","parts","split","join","JSON","parse","ex","extraChunk","pop","err","csvChunk","hasHeaders","push","endOfLine","module","exports"],"mappings":"AAAA;AACA;;AAEA,MAAMA,SAAS,GAAGC,OAAO,CAAC,QAAD,CAAP,CAAkBD,SAApC;;AAEA,MAAME,MAAN,SAAqBF,SAArB,CAA+B;AAE7BG,EAAAA,WAAW,CAACC,MAAD,EAAS;AAClB;AACA,SAAKC,OAAL,GAAeD,MAAf;AACA,SAAKE,QAAL,GAAgBF,MAAM,CAACE,QAAvB;AACA,SAAKC,QAAL,GAAgB,KAAKD,QAAL,CAAcE,OAAd,IAAyB,EAAzC;AACA,SAAKC,WAAL,GAAmB,KAAnB;AACA,SAAKC,UAAL,GAAkB,IAAlB;AACD;;AAEDC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACjB,QAAIC,IAAI,GAAG,IAAX;AACAA,IAAAA,IAAI,CAACC,MAAL,GAAcD,IAAI,CAACC,MAAL,IAAe,EAA7B,CAFiB,CAGjB;;AACA,QAAID,IAAI,CAACC,MAAL,CAAYC,MAAZ,CAAmB,CAAnB,KAAyB,GAA7B,EAAkCF,IAAI,CAACC,MAAL,GAAcD,IAAI,CAACC,MAAL,CAAYE,MAAZ,CAAmB,CAAnB,CAAd,CAJjB,CAKjB;;AACAJ,IAAAA,KAAK,GAAGC,IAAI,CAACC,MAAL,GAAcF,KAAK,CAACK,QAAN,EAAtB,CANiB,CAOjB;;AACA,QAAIJ,IAAI,CAACC,MAAL,CAAYI,MAAZ,GAAqB,CAAzB,EAA4BL,IAAI,CAACC,MAAL,GAAc,EAAd;AAC5B,WAAOF,KAAP;AACD;;AAEDO,EAAAA,UAAU,CAACC,IAAD,EAAO;AACf,QAAIA,IAAI,CAACL,MAAL,CAAY,CAAZ,KAAkB,GAAtB,EAA2BK,IAAI,GAAG,MAAMA,IAAb;AAC3B,QAAIA,IAAI,CAACL,MAAL,CAAYK,IAAI,CAACF,MAAL,GAAc,CAA1B,KAAgC,GAApC,EAAyCE,IAAI,IAAI,GAAR;AACzC,WAAOA,IAAP;AACD;;AAEDC,EAAAA,UAAU,CAACT,KAAD,EAAQU,QAAR,EAAkBC,IAAlB,EAAwB;AAChC,QAAIV,IAAI,GAAG,IAAX;AACA,QAAIW,IAAI,GAAG,IAAX,CAFgC,CAGhC;;AACAZ,IAAAA,KAAK,GAAG,KAAKD,WAAL,CAAiBC,KAAjB,CAAR;AACA,QAAI,CAACA,KAAL,EAAY,OAAOW,IAAI,CAAC,KAAKb,UAAN,CAAX,CALoB,CAMhC;;AACA,QAAIe,KAAK,GAAGb,KAAK,CAACc,KAAN,CAAY,GAAZ,CAAZ;;AACA,WAAOF,IAAI,KAAK,IAAT,IAAiBC,KAAK,CAACP,MAAN,GAAe,CAAvC,EAA0C;AACxC,UAAI;AACF,YAAIE,IAAI,GAAGP,IAAI,CAACM,UAAL,CAAgBM,KAAK,CAACE,IAAN,CAAW,GAAX,CAAhB,CAAX;;AACAH,QAAAA,IAAI,GAAGI,IAAI,CAACC,KAAL,CAAWT,IAAX,CAAP;AACD,OAHD,CAGE,OAAOU,EAAP,EAAW;AACX,aAAKpB,UAAL,GAAkBoB,EAAlB;AACA,YAAIC,UAAU,GAAGN,KAAK,CAACO,GAAN,EAAjB;AACAnB,QAAAA,IAAI,CAACC,MAAL,GAAciB,UAAU,IAAIlB,IAAI,CAACC,MAAL,IAAe,EAAnB,CAAxB;AACA,YAAIW,KAAK,CAACP,MAAN,GAAe,CAAnB,EAAsBO,KAAK,CAACA,KAAK,CAACP,MAAN,GAAe,CAAhB,CAAL,IAA2B,GAA3B;AACvB;AACF;;AACD,QAAI,CAACM,IAAL,EAAW,OAAOD,IAAI,EAAX;;AACX,SAAKlB,OAAL,CAAawB,KAAb,CAAmBL,IAAnB,EAAyB,CAACS,GAAD,EAAMC,QAAN,KAAmB;AAC1C,UAAID,GAAJ,EAAS,OAAOV,IAAI,CAACU,GAAD,CAAX;;AACT,UAAI,CAACpB,IAAI,CAACsB,UAAV,EAAsB;AACpBtB,QAAAA,IAAI,CAACsB,UAAL,GAAkB,IAAlB;AACAtB,QAAAA,IAAI,CAACuB,IAAL,CAAUvB,IAAI,CAACR,OAAL,CAAaG,OAAvB;AACD;;AACDK,MAAAA,IAAI,CAACuB,IAAL,CAAUvB,IAAI,CAACP,QAAL,CAAc+B,SAAd,GAA0BH,QAApC;AACAX,MAAAA,IAAI;AACL,KARD,EAQG,IARH;AASD;;AA1D4B;;AA6D/Be,MAAM,CAACC,OAAP,GAAiBrC,MAAjB","sourcesContent":["/* jshint node:true */\n'use strict';\n\nconst Transform = require('stream').Transform;\n\nclass Stream extends Transform {\n\n  constructor(parser) {\n    super();\n    this._parser = parser;\n    this._options = parser._options;\n    this._headers = this._options.headers || [];\n    this._hasHeaders = false;\n    this._lastError = null;\n  }\n\n  _mergeChunk(chunk) {\n    let self = this;\n    self._extra = self._extra || \"\";\n    // Remove starting comma\n    if (self._extra.charAt(0) == ',') self._extra = self._extra.substr(1);\n    // Append extra to chunk\n    chunk = self._extra + chunk.toString();\n    // Clear extra memory\n    if (self._extra.length > 0) self._extra = \"\";\n    return chunk;\n  }\n  \n  _wrapArray(data) {\n    if (data.charAt(0) != '[') data = '[' + data;\n    if (data.charAt(data.length - 1) != ']') data += ']';\n    return data;\n  }\n\n  _transform(chunk, encoding, done) {\n    let self = this;\n    let json = null;\n    // Append extra data to chunk data\n    chunk = this._mergeChunk(chunk);    \n    if (!chunk) return done(this._lastError);\n    // Split chunk in objects\n    let parts = chunk.split('}');\n    while (json === null && parts.length > 0) {\n      try {\n        let data = self._wrapArray(parts.join('}'));\n        json = JSON.parse(data);\n      } catch (ex) {\n        this._lastError = ex;\n        let extraChunk = parts.pop();\n        self._extra = extraChunk + (self._extra || \"\");\n        if (parts.length > 0) parts[parts.length - 1] += \"}\";\n      }\n    }    \n    if (!json) return done();\n    this._parser.parse(json, (err, csvChunk) => {\n      if (err) return done(err);\n      if (!self.hasHeaders) {\n        self.hasHeaders = true;\n        self.push(self._parser.headers);\n      }\n      self.push(self._options.endOfLine + csvChunk);\n      done();\n    }, true);\n  }\n}\n\nmodule.exports = Stream;\n"]},"metadata":{},"sourceType":"script"}