{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _get = function () {\n  function get(object, property, receiver) {\n    if (object === null) object = Function.prototype;\n    var desc = Object.getOwnPropertyDescriptor(object, property);\n\n    if (desc === undefined) {\n      var parent = Object.getPrototypeOf(object);\n\n      if (parent === null) {\n        return undefined;\n      } else {\n        return get(parent, property, receiver);\n      }\n    } else if (\"value\" in desc) {\n      return desc.value;\n    } else {\n      var getter = desc.get;\n\n      if (getter === undefined) {\n        return undefined;\n      }\n\n      return getter.call(receiver);\n    }\n  }\n\n  return get;\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _object = require('object.assign');\n\nvar _object2 = _interopRequireDefault(_object);\n\nvar _arrayPrototype = require('array.prototype.flat');\n\nvar _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);\n\nvar _has = require('has');\n\nvar _has2 = _interopRequireDefault(_has);\n\nvar _enzymeShallowEqual = require('enzyme-shallow-equal');\n\nvar _enzymeShallowEqual2 = _interopRequireDefault(_enzymeShallowEqual);\n\nvar _Utils = require('./Utils');\n\nvar _getAdapter = require('./getAdapter');\n\nvar _getAdapter2 = _interopRequireDefault(_getAdapter);\n\nvar _Debug = require('./Debug');\n\nvar _RSTTraversal = require('./RSTTraversal');\n\nvar _selectors = require('./selectors');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar NODE = (0, _Utils.sym)('__node__');\nvar NODES = (0, _Utils.sym)('__nodes__');\nvar RENDERER = (0, _Utils.sym)('__renderer__');\nvar UNRENDERED = (0, _Utils.sym)('__unrendered__');\nvar ROOT = (0, _Utils.sym)('__root__');\nvar OPTIONS = (0, _Utils.sym)('__options__');\nvar SET_STATE = (0, _Utils.sym)('__setState__');\nvar ROOT_NODES = (0, _Utils.sym)('__rootNodes__');\nvar CHILD_CONTEXT = (0, _Utils.sym)('__childContext__');\nvar WRAPPING_COMPONENT = (0, _Utils.sym)('__wrappingComponent__');\nvar PRIMARY_WRAPPER = (0, _Utils.sym)('__primaryWrapper__');\nvar ROOT_FINDER = (0, _Utils.sym)('__rootFinder__');\nvar PROVIDER_VALUES = (0, _Utils.sym)('__providerValues__');\n/**\n * Finds all nodes in the current wrapper nodes' render trees that match the provided predicate\n * function.\n *\n * @param {ShallowWrapper} wrapper\n * @param {Function} predicate\n * @param {Function} filter\n * @returns {ShallowWrapper}\n */\n\nfunction findWhereUnwrapped(wrapper, predicate) {\n  var filter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _RSTTraversal.treeFilter;\n  return wrapper.flatMap(function (n) {\n    return filter(n.getNodeInternal(), predicate);\n  });\n}\n/**\n * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n * the provided predicate function.\n *\n * @param {ShallowWrapper} wrapper\n * @param {Function} predicate\n * @returns {ShallowWrapper}\n */\n\n\nfunction filterWhereUnwrapped(wrapper, predicate) {\n  return wrapper.wrap(wrapper.getNodesInternal().filter(predicate).filter(Boolean));\n}\n/**\n * Ensure options passed to ShallowWrapper are valid. Throws otherwise.\n * @param {Object} options\n */\n\n\nfunction validateOptions(options) {\n  var lifecycleExperimental = options.lifecycleExperimental,\n      disableLifecycleMethods = options.disableLifecycleMethods,\n      enableComponentDidUpdateOnSetState = options.enableComponentDidUpdateOnSetState,\n      supportPrevContextArgumentOfComponentDidUpdate = options.supportPrevContextArgumentOfComponentDidUpdate,\n      lifecycles = options.lifecycles;\n\n  if (typeof lifecycleExperimental !== 'undefined' && typeof lifecycleExperimental !== 'boolean') {\n    throw new Error('lifecycleExperimental must be either true or false if provided');\n  }\n\n  if (typeof disableLifecycleMethods !== 'undefined' && typeof disableLifecycleMethods !== 'boolean') {\n    throw new Error('disableLifecycleMethods must be either true or false if provided');\n  }\n\n  if (lifecycleExperimental != null && disableLifecycleMethods != null && lifecycleExperimental === disableLifecycleMethods) {\n    throw new Error('lifecycleExperimental and disableLifecycleMethods cannot be set to the same value');\n  }\n\n  if (typeof enableComponentDidUpdateOnSetState !== 'undefined' && lifecycles.componentDidUpdate && lifecycles.componentDidUpdate.onSetState !== enableComponentDidUpdateOnSetState) {\n    throw new TypeError('the legacy enableComponentDidUpdateOnSetState option should be matched by `lifecycles: { componentDidUpdate: { onSetState: true } }`, for compatibility');\n  }\n\n  if (typeof supportPrevContextArgumentOfComponentDidUpdate !== 'undefined' && lifecycles.componentDidUpdate && lifecycles.componentDidUpdate.prevContext !== supportPrevContextArgumentOfComponentDidUpdate) {\n    throw new TypeError('the legacy supportPrevContextArgumentOfComponentDidUpdate option should be matched by `lifecycles: { componentDidUpdate: { prevContext: true } }`, for compatibility');\n  }\n}\n\nfunction getAdapterLifecycles(_ref) {\n  var options = _ref.options;\n  var _options$lifecycles = options.lifecycles,\n      lifecycles = _options$lifecycles === undefined ? {} : _options$lifecycles,\n      enableComponentDidUpdateOnSetState = options.enableComponentDidUpdateOnSetState,\n      supportPrevContextArgumentOfComponentDidUpdate = options.supportPrevContextArgumentOfComponentDidUpdate;\n  var hasLegacySetStateArg = typeof enableComponentDidUpdateOnSetState !== 'undefined';\n  var hasLegacyPrevContextArg = typeof supportPrevContextArgumentOfComponentDidUpdate !== 'undefined';\n  var componentDidUpdate = hasLegacySetStateArg || hasLegacyPrevContextArg ? (0, _object2['default'])({}, hasLegacySetStateArg && {\n    onSetState: !!enableComponentDidUpdateOnSetState\n  }, hasLegacyPrevContextArg && {\n    prevContext: !!supportPrevContextArgumentOfComponentDidUpdate\n  }) : null;\n  var originalGDSFP = lifecycles.getDerivedStateFromProps;\n  var getDerivedStateFromProps = originalGDSFP ? {\n    hasShouldComponentUpdateBug: !!originalGDSFP.hasShouldComponentUpdateBug\n  } : false;\n  return (0, _object2['default'])({}, lifecycles, {\n    setState: (0, _object2['default'])({}, lifecycles.setState),\n    getChildContext: (0, _object2['default'])({\n      calledByRenderer: true\n    }, lifecycles.getChildContext)\n  }, componentDidUpdate && {\n    componentDidUpdate: componentDidUpdate\n  }, {\n    getDerivedStateFromProps: getDerivedStateFromProps\n  });\n}\n\nfunction getRootNode(node) {\n  if (node.nodeType === 'host') {\n    return node;\n  }\n\n  return node.rendered;\n}\n\nfunction getRootNodeInternal(wrapper) {\n  if (wrapper[ROOT].length !== 1) {\n    throw new Error('getRootNodeInternal(wrapper) can only be called when wrapper wraps one node');\n  }\n\n  if (wrapper[ROOT] !== wrapper) {\n    return wrapper[ROOT_NODES][0];\n  }\n\n  return wrapper[ROOT][NODE];\n}\n\nfunction nodeParents(wrapper, node) {\n  return (0, _RSTTraversal.parentsOfNode)(node, getRootNodeInternal(wrapper));\n}\n\nfunction privateSetNodes(wrapper, nodes) {\n  if (!Array.isArray(nodes)) {\n    (0, _Utils.privateSet)(wrapper, NODE, nodes);\n    (0, _Utils.privateSet)(wrapper, NODES, [nodes]);\n  } else {\n    (0, _Utils.privateSet)(wrapper, NODE, nodes[0]);\n    (0, _Utils.privateSet)(wrapper, NODES, nodes);\n  }\n\n  (0, _Utils.privateSet)(wrapper, 'length', wrapper[NODES].length);\n}\n\nfunction pureComponentShouldComponentUpdate(prevProps, props, prevState, state) {\n  return !(0, _enzymeShallowEqual2['default'])(prevProps, props) || !(0, _enzymeShallowEqual2['default'])(prevState, state);\n}\n\nfunction isPureComponent(instance) {\n  return instance && instance.isPureReactComponent;\n}\n\nfunction getChildContext(node, hierarchy, renderer) {\n  var instance = node.instance,\n      Component = node.type;\n  var componentName = (0, _Utils.displayNameOfNode)(node); // Warn like react if childContextTypes is not defined:\n  // https://github.com/facebook/react/blob/1454a8be03794f5e0b23a7e7696cbbbdcf8b0f5d/packages/react-dom/src/server/ReactPartialRenderer.js#L639-L646\n\n  if (_typeof(Component.childContextTypes) !== 'object') {\n    // eslint-disable-next-line no-console\n    console.warn(String(componentName) + '.getChildContext(): childContextTypes must be defined in order to use getChildContext().');\n    return {};\n  } // Check childContextTypes like react:\n  // https://github.com/facebook/react/blob/1454a8be03794f5e0b23a7e7696cbbbdcf8b0f5d/packages/react-dom/src/server/ReactPartialRenderer.js#L630-L637\n\n\n  var childContext = instance.getChildContext();\n  Object.keys(childContext).forEach(function (key) {\n    if (!(key in Component.childContextTypes)) {\n      throw new Error(String(componentName) + '.getChildContext(): key \"' + String(key) + '\" is not defined in childContextTypes.');\n    }\n  });\n\n  if (typeof renderer.checkPropTypes === 'function') {\n    renderer.checkPropTypes(Component.childContextTypes, childContext, 'child context', hierarchy);\n  }\n\n  return childContext;\n}\n\nfunction spyOnGetChildContextInitialRender(nodes, adapter) {\n  if (!(0, _Utils.isCustomComponentElement)(nodes, adapter) || !nodes.type.prototype || typeof nodes.type.prototype.getChildContext !== 'function') {\n    return null;\n  }\n\n  return (0, _Utils.spyMethod)(nodes.type.prototype, 'getChildContext');\n}\n\nfunction privateSetChildContext(adapter, wrapper, instance, renderedNode, getChildContextSpy) {\n  var renderer = wrapper[RENDERER]; // We only support parent-based context.\n\n  if (adapter.options.legacyContextMode !== 'parent') {\n    return;\n  }\n\n  if (getChildContextSpy) {\n    (0, _Utils.privateSet)(wrapper, CHILD_CONTEXT, getChildContextSpy.getLastReturnValue());\n    getChildContextSpy.restore();\n  } else if (typeof instance.getChildContext === 'function') {\n    // If there's no spy but getChildContext is a function, that means our renderer\n    // is not going to call it for us, so we need to call it ourselves.\n    var nodeHierarchy = [wrapper[NODE]].concat(nodeParents(wrapper, wrapper[NODE]));\n    var childContext = getChildContext(renderedNode, nodeHierarchy, renderer);\n    (0, _Utils.privateSet)(wrapper, CHILD_CONTEXT, childContext);\n  } else {\n    (0, _Utils.privateSet)(wrapper, CHILD_CONTEXT, null);\n  }\n}\n\nfunction mockSCUIfgDSFPReturnNonNull(node, state) {\n  var getDerivedStateFromProps = node.type.getDerivedStateFromProps;\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    // we try to fix a React shallow renderer bug here.\n    // (facebook/react#14607, which has been fixed in react 16.8):\n    // when gDSFP return derived state, it will set instance state in shallow renderer before SCU,\n    // this will cause `this.state` in sCU be the updated state, which is wrong behavior.\n    // so we have to wrap sCU to pass the old state to original sCU.\n    var instance = node.instance;\n\n    var _spyMethod = (0, _Utils.spyMethod)(instance, 'shouldComponentUpdate', function (originalSCU) {\n      return function () {\n        function shouldComponentUpdate() {\n          instance.state = state;\n\n          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          var sCUResult = originalSCU.apply(instance, args);\n          var nextState = args[1];\n          instance.state = nextState;\n          restore();\n          return sCUResult;\n        }\n\n        return shouldComponentUpdate;\n      }();\n    }),\n        restore = _spyMethod.restore;\n  }\n}\n/**\n * Recursively dive()s every custom component in a wrapper until\n * the target component is found.\n *\n * @param {ShallowWrapper} wrapper A ShallowWrapper to search\n * @param {ComponentType} target A react custom component that, when found, will end recursion\n * @param {Adapter} adapter An Enzyme adapter\n * @returns {ShallowWrapper|undefined} A ShallowWrapper for the target, or\n *  undefined if it can't be found\n */\n\n\nfunction deepRender(wrapper, target, adapter) {\n  var node = wrapper[NODE];\n  var element = node && adapter.nodeToElement(node);\n\n  if (wrapper.type() === target) {\n    return wrapper.dive();\n  }\n\n  if (element && (0, _Utils.isCustomComponentElement)(element, adapter)) {\n    return deepRender(wrapper.dive(), target, adapter);\n  }\n\n  var children = wrapper.children();\n\n  for (var i = 0; i < children.length; i += 1) {\n    var found = deepRender(children.at(i), target, adapter);\n\n    if (typeof found !== 'undefined') {\n      return found;\n    }\n  }\n\n  return undefined;\n}\n/**\n * Deep-renders the `wrappingComponent` and returns the context that should\n * be accessible to the primary wrapper.\n *\n * @param {WrappingComponentWrapper} wrapper The `WrappingComponentWrapper` for a\n *  `wrappingComponent`\n * @param {Adapter} adapter An Enzyme adapter\n * @returns {object} An object containing an object of legacy context values and a Map of\n *  `createContext()` Provider values.\n */\n\n\nfunction getContextFromWrappingComponent(wrapper, adapter) {\n  var rootFinder = deepRender(wrapper, wrapper[ROOT_FINDER], adapter);\n\n  if (!rootFinder) {\n    throw new Error('`wrappingComponent` must render its children!');\n  }\n\n  return {\n    legacyContext: rootFinder[OPTIONS].context,\n    providerValues: rootFinder[PROVIDER_VALUES]\n  };\n}\n/**\n * Makes options specifically for `ShallowWrapper`. Most of the logic here is around rendering\n * a `wrappingComponent` (if one was provided) and adding the child context of that component\n * to `options.context`.\n *\n * @param {ReactElement} nodes the nodes passed to `ShallowWrapper`\n * @param {ShallowWrapper} root this `ShallowWrapper`'s parent. If this is passed, options are\n *  not transformed.\n * @param {*} passedOptions the options passed to `ShallowWrapper`.\n * @param {*} wrapper the `ShallowWrapper` itself\n * @returns {Object} the decorated and transformed options\n */\n\n\nfunction makeShallowOptions(nodes, root, passedOptions, wrapper) {\n  var options = (0, _Utils.makeOptions)(passedOptions);\n  var adapter = (0, _getAdapter2['default'])(passedOptions);\n  (0, _Utils.privateSet)(options, PROVIDER_VALUES, passedOptions[PROVIDER_VALUES]);\n\n  if (root || !(0, _Utils.isCustomComponent)(options.wrappingComponent, adapter)) {\n    return options;\n  }\n\n  if (typeof adapter.wrapWithWrappingComponent !== 'function') {\n    throw new TypeError('your adapter does not support `wrappingComponent`. Try upgrading it!');\n  }\n\n  var _adapter$wrapWithWrap = adapter.wrapWithWrappingComponent(nodes, options),\n      wrappedNode = _adapter$wrapWithWrap.node,\n      RootFinder = _adapter$wrapWithWrap.RootFinder; // eslint-disable-next-line no-use-before-define\n\n\n  var wrappingComponent = new WrappingComponentWrapper(wrappedNode, wrapper, RootFinder);\n\n  var _getContextFromWrappi = getContextFromWrappingComponent(wrappingComponent, adapter),\n      wrappingComponentLegacyContext = _getContextFromWrappi.legacyContext,\n      wrappingComponentProviderValues = _getContextFromWrappi.providerValues;\n\n  (0, _Utils.privateSet)(wrapper, WRAPPING_COMPONENT, wrappingComponent);\n  return (0, _object2['default'])({}, options, _defineProperty({\n    context: (0, _object2['default'])({}, options.context, wrappingComponentLegacyContext)\n  }, PROVIDER_VALUES, wrappingComponentProviderValues));\n}\n\nfunction makeInheritedChildOptions(wrapper) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var childOptions = (0, _object2['default'])({}, wrapper[OPTIONS], options, {\n    context: options.context || (0, _object2['default'])({}, wrapper[OPTIONS].context, wrapper[ROOT][CHILD_CONTEXT])\n  });\n  (0, _Utils.privateSet)(childOptions, PROVIDER_VALUES, wrapper[ROOT][PROVIDER_VALUES]);\n  return childOptions;\n}\n/**\n * @class ShallowWrapper\n */\n\n\nvar ShallowWrapper = function () {\n  function ShallowWrapper(nodes, root) {\n    var _this = this;\n\n    var passedOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, ShallowWrapper);\n\n    validateOptions(passedOptions);\n    var options = makeShallowOptions(nodes, root, passedOptions, this);\n    var adapter = (0, _getAdapter2['default'])(options);\n    var lifecycles = getAdapterLifecycles(adapter); // mounting a ShallowRender component\n\n    if (!root) {\n      if (!adapter.isValidElement(nodes)) {\n        throw new TypeError('ShallowWrapper can only wrap valid elements');\n      }\n\n      var getChildContextSpy = lifecycles.getChildContext.calledByRenderer ? spyOnGetChildContextInitialRender(nodes, adapter) : null;\n      (0, _Utils.privateSet)(this, ROOT, this);\n      (0, _Utils.privateSet)(this, UNRENDERED, nodes);\n      var renderer = adapter.createRenderer((0, _object2['default'])({\n        mode: 'shallow'\n      }, options));\n      (0, _Utils.privateSet)(this, RENDERER, renderer);\n      var providerValues = new Map(options[PROVIDER_VALUES] || []);\n      this[RENDERER].render(nodes, options.context, {\n        providerValues: providerValues\n      });\n      var renderedNode = this[RENDERER].getNode();\n      privateSetNodes(this, getRootNode(renderedNode));\n      (0, _Utils.privateSet)(this, OPTIONS, options);\n      (0, _Utils.privateSet)(this, PROVIDER_VALUES, providerValues);\n      var instance = renderedNode.instance;\n\n      if (instance && !options.disableLifecycleMethods) {\n        // Ensure to call componentDidUpdate when instance.setState is called\n        if (lifecycles.componentDidUpdate.onSetState && !instance[SET_STATE]) {\n          (0, _Utils.privateSet)(instance, SET_STATE, instance.setState);\n\n          instance.setState = function (updater) {\n            var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n            return _this.setState.apply(_this, _toConsumableArray(callback == null ? [updater] : [updater, callback]));\n          };\n        }\n\n        if (typeof instance.componentDidMount === 'function') {\n          this[RENDERER].batchedUpdates(function () {\n            instance.componentDidMount();\n          });\n        }\n\n        privateSetChildContext(adapter, this, instance, renderedNode, getChildContextSpy);\n      } // creating a child component through enzyme's ShallowWrapper APIs.\n\n    } else {\n      (0, _Utils.privateSet)(this, ROOT, root);\n      (0, _Utils.privateSet)(this, UNRENDERED, null);\n      (0, _Utils.privateSet)(this, RENDERER, root[RENDERER]);\n      privateSetNodes(this, nodes);\n      (0, _Utils.privateSet)(this, OPTIONS, root[OPTIONS]);\n      (0, _Utils.privateSet)(this, ROOT_NODES, root[NODES]);\n      (0, _Utils.privateSet)(this, PROVIDER_VALUES, null);\n    }\n  }\n  /**\n   * Returns the root wrapper\n   *\n   * @return {ShallowWrapper}\n   */\n\n\n  _createClass(ShallowWrapper, [{\n    key: 'root',\n    value: function () {\n      function root() {\n        return this[ROOT];\n      }\n\n      return root;\n    }()\n    /**\n     * Returns the wrapped component.\n     *\n     * @return {ReactComponent}\n     */\n\n  }, {\n    key: 'getNodeInternal',\n    value: function () {\n      function getNodeInternal() {\n        if (this.length !== 1) {\n          throw new Error('ShallowWrapper::getNode() can only be called when wrapping one node');\n        }\n\n        if (this[ROOT] === this) {\n          this.update();\n        }\n\n        return this[NODE];\n      }\n\n      return getNodeInternal;\n    }()\n    /**\n     * Returns the the wrapped components.\n     *\n     * @return {Array<ReactComponent>}\n     */\n\n  }, {\n    key: 'getNodesInternal',\n    value: function () {\n      function getNodesInternal() {\n        if (this[ROOT] === this && this.length === 1) {\n          this.update();\n        }\n\n        return this[NODES];\n      }\n\n      return getNodesInternal;\n    }()\n    /**\n     * Returns the wrapped ReactElement.\n     *\n     * @return {ReactElement}\n     */\n\n  }, {\n    key: 'getElement',\n    value: function () {\n      function getElement() {\n        var _this2 = this;\n\n        return this.single('getElement', function (n) {\n          return (0, _getAdapter2['default'])(_this2[OPTIONS]).nodeToElement(n);\n        });\n      }\n\n      return getElement;\n    }()\n    /**\n     * Returns the wrapped ReactElements.\n     *\n     * @return {Array<ReactElement>}\n     */\n\n  }, {\n    key: 'getElements',\n    value: function () {\n      function getElements() {\n        var _this3 = this;\n\n        return this.getNodesInternal().map(function (n) {\n          return (0, _getAdapter2['default'])(_this3[OPTIONS]).nodeToElement(n);\n        });\n      }\n\n      return getElements;\n    }() // eslint-disable-next-line class-methods-use-this\n\n  }, {\n    key: 'getNode',\n    value: function () {\n      function getNode() {\n        throw new Error('ShallowWrapper::getNode() is no longer supported. Use ShallowWrapper::getElement() instead');\n      }\n\n      return getNode;\n    }() // eslint-disable-next-line class-methods-use-this\n\n  }, {\n    key: 'getNodes',\n    value: function () {\n      function getNodes() {\n        throw new Error('ShallowWrapper::getNodes() is no longer supported. Use ShallowWrapper::getElements() instead');\n      }\n\n      return getNodes;\n    }()\n    /**\n     * Gets the instance of the component being rendered as the root node passed into `shallow()`.\n     *\n     * NOTE: can only be called on a wrapper instance that is also the root instance.\n     *\n     * Example:\n     * ```\n     * const wrapper = shallow(<MyComponent />);\n     * const inst = wrapper.instance();\n     * expect(inst).to.be.instanceOf(MyComponent);\n     * ```\n     * @returns {ReactComponent}\n     */\n\n  }, {\n    key: 'instance',\n    value: function () {\n      function instance() {\n        if (this[ROOT] !== this) {\n          throw new Error('ShallowWrapper::instance() can only be called on the root');\n        }\n\n        return this[RENDERER].getNode().instance;\n      }\n\n      return instance;\n    }()\n    /**\n     * If a `wrappingComponent` was passed in `options`, this methods returns a `ShallowWrapper`\n     * around the rendered `wrappingComponent`. This `ShallowWrapper` can be used to update the\n     * `wrappingComponent`'s props, state, etc.\n     *\n     * @returns ShallowWrapper\n     */\n\n  }, {\n    key: 'getWrappingComponent',\n    value: function () {\n      function getWrappingComponent() {\n        if (this[ROOT] !== this) {\n          throw new Error('ShallowWrapper::getWrappingComponent() can only be called on the root');\n        }\n\n        if (!this[OPTIONS].wrappingComponent) {\n          throw new Error('ShallowWrapper::getWrappingComponent() can only be called on a wrapper that was originally passed a `wrappingComponent` option');\n        }\n\n        return this[WRAPPING_COMPONENT];\n      }\n\n      return getWrappingComponent;\n    }()\n    /**\n     * Forces a re-render. Useful to run before checking the render output if something external\n     * may be updating the state of the component somewhere.\n     *\n     * NOTE: can only be called on a wrapper instance that is also the root instance.\n     *\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'update',\n    value: function () {\n      function update() {\n        if (this[ROOT] !== this) {\n          throw new Error('ShallowWrapper::update() can only be called on the root');\n        }\n\n        if (this.length !== 1) {\n          throw new Error('ShallowWrapper::update() can only be called when wrapping one node');\n        }\n\n        privateSetNodes(this, getRootNode(this[RENDERER].getNode()));\n        return this;\n      }\n\n      return update;\n    }()\n    /**\n     * A method that unmounts the component. This can be used to simulate a component going through\n     * and unmount/mount lifecycle.\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'unmount',\n    value: function () {\n      function unmount() {\n        this[RENDERER].unmount();\n\n        if (this[ROOT][WRAPPING_COMPONENT]) {\n          this[ROOT][WRAPPING_COMPONENT].unmount();\n        }\n\n        return this;\n      }\n\n      return unmount;\n    }()\n    /**\n     * A method is for re-render with new props and context.\n     * This calls componentDidUpdate method if disableLifecycleMethods is not enabled.\n     *\n     * NOTE: can only be called on a wrapper instance that is also the root instance.\n     *\n     * @param {Object} props\n     * @param {Object} context\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'rerender',\n    value: function () {\n      function rerender(props, context) {\n        var _this4 = this;\n\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n        this.single('rerender', function () {\n          (0, _Utils.withSetStateAllowed)(function () {\n            // NOTE(lmr): In react 16, instances will be null for SFCs, but\n            // rerendering with props/context is still a valid thing to do. In\n            // this case, state will be undefined, but props/context will exist.\n            var node = _this4[RENDERER].getNode();\n\n            var instance = node.instance || {};\n            var type = node.type || {};\n            var state = instance.state;\n            var prevProps = instance.props || _this4[UNRENDERED].props;\n            var prevContext = instance.context || _this4[OPTIONS].context;\n            var nextContext = context || prevContext;\n\n            if (context) {\n              _this4[OPTIONS] = (0, _object2['default'])({}, _this4[OPTIONS], {\n                context: nextContext\n              });\n            }\n\n            _this4[RENDERER].batchedUpdates(function () {\n              // When shouldComponentUpdate returns false we shouldn't call componentDidUpdate.\n              // so we spy shouldComponentUpdate to get the result.\n              var lifecycles = getAdapterLifecycles(adapter);\n              var shouldRender = true;\n              var shouldComponentUpdateSpy = void 0;\n              var getChildContextSpy = void 0;\n\n              if (!_this4[OPTIONS].disableLifecycleMethods && instance) {\n                if (typeof instance.shouldComponentUpdate === 'function') {\n                  var gDSFP = lifecycles.getDerivedStateFromProps;\n\n                  if (gDSFP && gDSFP.hasShouldComponentUpdateBug) {\n                    mockSCUIfgDSFPReturnNonNull(node, state);\n                  }\n\n                  shouldComponentUpdateSpy = (0, _Utils.spyMethod)(instance, 'shouldComponentUpdate');\n                }\n\n                if (lifecycles.getChildContext.calledByRenderer && typeof instance.getChildContext === 'function') {\n                  getChildContextSpy = (0, _Utils.spyMethod)(instance, 'getChildContext');\n                }\n              }\n\n              if (!shouldComponentUpdateSpy && isPureComponent(instance)) {\n                shouldRender = pureComponentShouldComponentUpdate(prevProps, props, state, instance.state);\n              }\n\n              if (props) _this4[UNRENDERED] = (0, _Utils.cloneElement)(adapter, _this4[UNRENDERED], props);\n\n              _this4[RENDERER].render(_this4[UNRENDERED], nextContext, {\n                providerValues: _this4[PROVIDER_VALUES]\n              });\n\n              if (shouldComponentUpdateSpy) {\n                shouldRender = shouldComponentUpdateSpy.getLastReturnValue();\n                shouldComponentUpdateSpy.restore();\n              }\n\n              if (shouldRender && !_this4[OPTIONS].disableLifecycleMethods && instance) {\n                privateSetChildContext(adapter, _this4, instance, node, getChildContextSpy);\n\n                if (lifecycles.getSnapshotBeforeUpdate) {\n                  var snapshot = void 0;\n\n                  if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n                    snapshot = instance.getSnapshotBeforeUpdate(prevProps, state);\n                  }\n\n                  if (lifecycles.componentDidUpdate && typeof instance.componentDidUpdate === 'function' && (!state || (0, _enzymeShallowEqual2['default'])(state, _this4.instance().state) || typeof type.getDerivedStateFromProps === 'function')) {\n                    instance.componentDidUpdate(prevProps, state, snapshot);\n                  }\n                } else if (lifecycles.componentDidUpdate && typeof instance.componentDidUpdate === 'function') {\n                  if (lifecycles.componentDidUpdate.prevContext) {\n                    instance.componentDidUpdate(prevProps, state, prevContext);\n                  } else if (!state || (0, _enzymeShallowEqual2['default'])(_this4.instance().state, state)) {\n                    instance.componentDidUpdate(prevProps, state);\n                  }\n                } // If it doesn't need to rerender, update only its props.\n\n              } else if (!(0, _enzymeShallowEqual2['default'])(props, instance.props)) {\n                instance.props = (Object.freeze || Object)((0, _object2['default'])({}, instance.props, props));\n              }\n\n              _this4.update();\n            });\n          });\n        });\n        return this;\n      }\n\n      return rerender;\n    }()\n    /**\n     * A method that sets the props of the root component, and re-renders. Useful for when you are\n     * wanting to test how the component behaves over time with changing props. Calling this, for\n     * instance, will call the `componentWillReceiveProps` lifecycle method.\n     *\n     * Similar to `setState`, this method accepts a props object and will merge it in with the already\n     * existing props.\n     *\n     * NOTE: can only be called on a wrapper instance that is also the root instance.\n     *\n     * @param {Object} props object\n     * @param {Function} cb - callback function\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'setProps',\n    value: function () {\n      function setProps(props) {\n        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n        if (this[ROOT] !== this) {\n          throw new Error('ShallowWrapper::setProps() can only be called on the root');\n        }\n\n        if (arguments.length > 1 && typeof callback !== 'function') {\n          throw new TypeError('ReactWrapper::setProps() expects a function as its second argument');\n        }\n\n        this.rerender(props);\n\n        if (callback) {\n          callback();\n        }\n\n        return this;\n      }\n\n      return setProps;\n    }()\n    /**\n     * A method to invoke `setState` on the root component instance similar to how you might in the\n     * definition of the component, and re-renders.  This method is useful for testing your component\n     * in hard to achieve states, however should be used sparingly. If possible, you should utilize\n     * your component's external API in order to get it into whatever state you want to test, in order\n     * to be as accurate of a test as possible. This is not always practical, however.\n     *\n     * NOTE: can only be called on a wrapper instance that is also the root instance.\n     *\n     * @param {Object} state to merge\n     * @param {Function} cb - callback function\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'setState',\n    value: function () {\n      function setState(state) {\n        var _this5 = this;\n\n        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n        if (this[ROOT] !== this) {\n          throw new Error('ShallowWrapper::setState() can only be called on the root');\n        }\n\n        if (this.instance() === null || this[RENDERER].getNode().nodeType !== 'class') {\n          throw new Error('ShallowWrapper::setState() can only be called on class components');\n        }\n\n        if (arguments.length > 1 && typeof callback !== 'function') {\n          throw new TypeError('ReactWrapper::setState() expects a function as its second argument');\n        }\n\n        this.single('setState', function () {\n          (0, _Utils.withSetStateAllowed)(function () {\n            var adapter = (0, _getAdapter2['default'])(_this5[OPTIONS]);\n            var lifecycles = getAdapterLifecycles(adapter);\n\n            var node = _this5[RENDERER].getNode();\n\n            var instance = node.instance;\n            var prevProps = instance.props;\n            var prevState = instance.state;\n            var prevContext = instance.context;\n            var statePayload = typeof state === 'function' ? state.call(instance, prevState, prevProps) : state; // returning null or undefined prevents the update in React 16+\n            // https://github.com/facebook/react/pull/12756\n\n            var maybeHasUpdate = !lifecycles.setState.skipsComponentDidUpdateOnNullish || statePayload != null; // When shouldComponentUpdate returns false we shouldn't call componentDidUpdate.\n            // so we spy shouldComponentUpdate to get the result.\n\n            var shouldComponentUpdateSpy = void 0;\n            var getChildContextSpy = void 0;\n            var shouldRender = true;\n\n            if (!_this5[OPTIONS].disableLifecycleMethods && instance) {\n              if (lifecycles.componentDidUpdate && lifecycles.componentDidUpdate.onSetState && typeof instance.shouldComponentUpdate === 'function') {\n                var gDSFP = lifecycles.getDerivedStateFromProps;\n\n                if (gDSFP && gDSFP.hasShouldComponentUpdateBug) {\n                  mockSCUIfgDSFPReturnNonNull(node, state);\n                }\n\n                shouldComponentUpdateSpy = (0, _Utils.spyMethod)(instance, 'shouldComponentUpdate');\n              }\n\n              if (lifecycles.getChildContext.calledByRenderer && typeof instance.getChildContext === 'function') {\n                getChildContextSpy = (0, _Utils.spyMethod)(instance, 'getChildContext');\n              }\n            }\n\n            if (!shouldComponentUpdateSpy && isPureComponent(instance)) {\n              shouldRender = pureComponentShouldComponentUpdate(prevProps, instance.props, prevState, (0, _object2['default'])({}, prevState, statePayload));\n            } // We don't pass the setState callback here\n            // to guarantee to call the callback after finishing the render\n\n\n            if (instance[SET_STATE]) {\n              instance[SET_STATE](statePayload);\n            } else {\n              instance.setState(statePayload);\n            }\n\n            if (shouldComponentUpdateSpy) {\n              shouldRender = shouldComponentUpdateSpy.getLastReturnValue();\n              shouldComponentUpdateSpy.restore();\n            }\n\n            if (maybeHasUpdate && shouldRender && !_this5[OPTIONS].disableLifecycleMethods) {\n              privateSetChildContext(adapter, _this5, instance, node, getChildContextSpy);\n\n              if (lifecycles.componentDidUpdate && lifecycles.componentDidUpdate.onSetState) {\n                if (lifecycles.getSnapshotBeforeUpdate && typeof instance.getSnapshotBeforeUpdate === 'function') {\n                  var snapshot = instance.getSnapshotBeforeUpdate(prevProps, prevState);\n\n                  if (typeof instance.componentDidUpdate === 'function') {\n                    instance.componentDidUpdate(prevProps, prevState, snapshot);\n                  }\n                } else if (typeof instance.componentDidUpdate === 'function') {\n                  if (lifecycles.componentDidUpdate.prevContext) {\n                    instance.componentDidUpdate(prevProps, prevState, prevContext);\n                  } else {\n                    instance.componentDidUpdate(prevProps, prevState);\n                  }\n                }\n              }\n            }\n\n            _this5.update(); // call the setState callback\n\n\n            if (callback) {\n              if (adapter.invokeSetStateCallback) {\n                adapter.invokeSetStateCallback(instance, callback);\n              } else {\n                callback.call(instance);\n              }\n            }\n          });\n        });\n        return this;\n      }\n\n      return setState;\n    }()\n    /**\n     * A method that sets the context of the root component, and re-renders. Useful for when you are\n     * wanting to test how the component behaves over time with changing contexts.\n     *\n     * NOTE: can only be called on a wrapper instance that is also the root instance.\n     *\n     * @param {Object} context object\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'setContext',\n    value: function () {\n      function setContext(context) {\n        if (this[ROOT] !== this) {\n          throw new Error('ShallowWrapper::setContext() can only be called on the root');\n        }\n\n        if (!this[OPTIONS].context) {\n          throw new Error('ShallowWrapper::setContext() can only be called on a wrapper that was originally passed a context option');\n        }\n\n        return this.rerender(null, context);\n      }\n\n      return setContext;\n    }()\n    /**\n     * Whether or not a given react element exists in the shallow render tree.\n     *\n     * Example:\n     * ```\n     * const wrapper = shallow(<MyComponent />);\n     * expect(wrapper.contains(<div className=\"foo bar\" />)).to.equal(true);\n     * ```\n     *\n     * @param {ReactElement|Array<ReactElement>} nodeOrNodes\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'contains',\n    value: function () {\n      function contains(nodeOrNodes) {\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n\n        if (!(0, _Utils.isReactElementAlike)(nodeOrNodes, adapter)) {\n          throw new Error('ShallowWrapper::contains() can only be called with a ReactElement (or an array of them), a string, or a number as an argument.');\n        }\n\n        var predicate = Array.isArray(nodeOrNodes) ? function (other) {\n          return (0, _Utils.containsChildrenSubArray)(_Utils.nodeEqual, other, nodeOrNodes.map(function (node) {\n            return adapter.elementToNode(node);\n          }));\n        } : function (other) {\n          return (0, _Utils.nodeEqual)(adapter.elementToNode(nodeOrNodes), other);\n        };\n        return findWhereUnwrapped(this, predicate).length > 0;\n      }\n\n      return contains;\n    }()\n    /**\n     * Whether or not a given react element exists in the shallow render tree.\n     * Match is based on the expected element and not on wrappers element.\n     * It will determine if one of the wrappers element \"looks like\" the expected\n     * element by checking if all props of the expected element are present\n     * on the wrappers element and equals to each other.\n     *\n     * Example:\n     * ```\n     * // MyComponent outputs <div><div class=\"foo\">Hello</div></div>\n     * const wrapper = shallow(<MyComponent />);\n     * expect(wrapper.containsMatchingElement(<div>Hello</div>)).to.equal(true);\n     * ```\n     *\n     * @param {ReactElement} node\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'containsMatchingElement',\n    value: function () {\n      function containsMatchingElement(node) {\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n        var rstNode = adapter.elementToNode(node);\n\n        var predicate = function () {\n          function predicate(other) {\n            return (0, _Utils.nodeMatches)(rstNode, other, function (a, b) {\n              return a <= b;\n            });\n          }\n\n          return predicate;\n        }();\n\n        return findWhereUnwrapped(this, predicate).length > 0;\n      }\n\n      return containsMatchingElement;\n    }()\n    /**\n     * Whether or not all the given react elements exist in the shallow render tree.\n     * Match is based on the expected element and not on wrappers element.\n     * It will determine if one of the wrappers element \"looks like\" the expected\n     * element by checking if all props of the expected element are present\n     * on the wrappers element and equals to each other.\n     *\n     * Example:\n     * ```\n     * const wrapper = shallow(<MyComponent />);\n     * expect(wrapper.containsAllMatchingElements([\n     *   <div>Hello</div>,\n     *   <div>Goodbye</div>,\n     * ])).to.equal(true);\n     * ```\n     *\n     * @param {Array<ReactElement>} nodes\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'containsAllMatchingElements',\n    value: function () {\n      function containsAllMatchingElements(nodes) {\n        var _this6 = this;\n\n        if (!Array.isArray(nodes)) {\n          throw new TypeError('nodes should be an Array');\n        }\n\n        return nodes.every(function (node) {\n          return _this6.containsMatchingElement(node);\n        });\n      }\n\n      return containsAllMatchingElements;\n    }()\n    /**\n     * Whether or not one of the given react elements exists in the shallow render tree.\n     * Match is based on the expected element and not on wrappers element.\n     * It will determine if one of the wrappers element \"looks like\" the expected\n     * element by checking if all props of the expected element are present\n     * on the wrappers element and equals to each other.\n     *\n     * Example:\n     * ```\n     * const wrapper = shallow(<MyComponent />);\n     * expect(wrapper.containsAnyMatchingElements([\n     *   <div>Hello</div>,\n     *   <div>Goodbye</div>,\n     * ])).to.equal(true);\n     * ```\n     *\n     * @param {Array<ReactElement>} nodes\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'containsAnyMatchingElements',\n    value: function () {\n      function containsAnyMatchingElements(nodes) {\n        var _this7 = this;\n\n        return Array.isArray(nodes) && nodes.some(function (node) {\n          return _this7.containsMatchingElement(node);\n        });\n      }\n\n      return containsAnyMatchingElements;\n    }()\n    /**\n     * Whether or not a given react element exists in the render tree.\n     *\n     * Example:\n     * ```\n     * const wrapper = shallow(<MyComponent />);\n     * expect(wrapper.contains(<div className=\"foo bar\" />)).to.equal(true);\n     * ```\n     *\n     * @param {ReactElement} node\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'equals',\n    value: function () {\n      function equals(node) {\n        var _this8 = this;\n\n        return this.single('equals', function () {\n          return (0, _Utils.nodeEqual)(_this8.getNodeInternal(), node);\n        });\n      }\n\n      return equals;\n    }()\n    /**\n     * Whether or not a given react element matches the render tree.\n     * Match is based on the expected element and not on wrapper root node.\n     * It will determine if the wrapper root node \"looks like\" the expected\n     * element by checking if all props of the expected element are present\n     * on the wrapper root node and equals to each other.\n     *\n     * Example:\n     * ```\n     * // MyComponent outputs <div class=\"foo\">Hello</div>\n     * const wrapper = shallow(<MyComponent />);\n     * expect(wrapper.matchesElement(<div>Hello</div>)).to.equal(true);\n     * ```\n     *\n     * @param {ReactElement} node\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'matchesElement',\n    value: function () {\n      function matchesElement(node) {\n        var _this9 = this;\n\n        return this.single('matchesElement', function () {\n          var adapter = (0, _getAdapter2['default'])(_this9[OPTIONS]);\n          var rstNode = adapter.elementToNode(node);\n          return (0, _Utils.nodeMatches)(rstNode, _this9.getNodeInternal(), function (a, b) {\n            return a <= b;\n          });\n        });\n      }\n\n      return matchesElement;\n    }()\n    /**\n     * Finds every node in the render tree of the current wrapper that matches the provided selector.\n     *\n     * @param {EnzymeSelector} selector\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'find',\n    value: function () {\n      function find(selector) {\n        return this.wrap((0, _selectors.reduceTreesBySelector)(selector, this.getNodesInternal()));\n      }\n\n      return find;\n    }()\n    /**\n     * Returns whether or not current node matches a provided selector.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @param {EnzymeSelector} selector\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'is',\n    value: function () {\n      function is(selector) {\n        var predicate = (0, _selectors.buildPredicate)(selector);\n        return this.single('is', function (n) {\n          return predicate(n);\n        });\n      }\n\n      return is;\n    }()\n    /**\n     * Returns true if the component rendered nothing, i.e., null or false.\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'isEmptyRender',\n    value: function () {\n      function isEmptyRender() {\n        var nodes = this.getNodesInternal();\n        return nodes.every(function (n) {\n          return (0, _Utils.isEmptyValue)(n);\n        });\n      }\n\n      return isEmptyRender;\n    }()\n    /**\n     * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n     * the provided predicate function. The predicate should receive a wrapped node as its first\n     * argument.\n     *\n     * @param {Function} predicate\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'filterWhere',\n    value: function () {\n      function filterWhere(predicate) {\n        var _this10 = this;\n\n        return filterWhereUnwrapped(this, function (n) {\n          return predicate(_this10.wrap(n));\n        });\n      }\n\n      return filterWhere;\n    }()\n    /**\n     * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n     * the provided selector.\n     *\n     * @param {EnzymeSelector} selector\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'filter',\n    value: function () {\n      function filter(selector) {\n        var predicate = (0, _selectors.buildPredicate)(selector);\n        return filterWhereUnwrapped(this, predicate);\n      }\n\n      return filter;\n    }()\n    /**\n     * Returns a new wrapper instance with only the nodes of the current wrapper that did not match\n     * the provided selector. Essentially the inverse of `filter`.\n     *\n     * @param {EnzymeSelector} selector\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'not',\n    value: function () {\n      function not(selector) {\n        var predicate = (0, _selectors.buildPredicate)(selector);\n        return filterWhereUnwrapped(this, function (n) {\n          return !predicate(n);\n        });\n      }\n\n      return not;\n    }()\n    /**\n     * Returns a string of the rendered text of the current render tree.  This function should be\n     * looked at with skepticism if being used to test what the actual HTML output of the component\n     * will be. If that is what you would like to test, use enzyme's `render` function instead.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @returns {String}\n     */\n\n  }, {\n    key: 'text',\n    value: function () {\n      function text() {\n        return this.single('text', _RSTTraversal.getTextFromNode);\n      }\n\n      return text;\n    }()\n    /**\n     * Returns the HTML of the node.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @returns {String}\n     */\n\n  }, {\n    key: 'html',\n    value: function () {\n      function html() {\n        var _this11 = this;\n\n        return this.single('html', function (n) {\n          if (_this11.type() === null) return null;\n          var adapter = (0, _getAdapter2['default'])(_this11[OPTIONS]);\n          var renderer = adapter.createRenderer((0, _object2['default'])({}, _this11[OPTIONS], {\n            mode: 'string'\n          }));\n          return renderer.render(adapter.nodeToElement(n));\n        });\n      }\n\n      return html;\n    }()\n    /**\n     * Returns the current node rendered to HTML and wrapped in a CheerioWrapper.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @returns {CheerioWrapper}\n     */\n\n  }, {\n    key: 'render',\n    value: function () {\n      function render() {\n        var html = this.html();\n        return (0, _Utils.loadCheerioRoot)(html);\n      }\n\n      return render;\n    }()\n    /**\n     * Used to simulate events. Pass an eventname and (optionally) event arguments. This method of\n     * testing events should be met with some skepticism.\n     *\n     * @param {String} event\n     * @param {Array} args\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'simulate',\n    value: function () {\n      function simulate(event) {\n        var _this12 = this;\n\n        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n\n        return this.single('simulate', function (n) {\n          var _RENDERER;\n\n          (_RENDERER = _this12[RENDERER]).simulateEvent.apply(_RENDERER, [n, event].concat(args));\n\n          _this12[ROOT].update();\n\n          return _this12;\n        });\n      }\n\n      return simulate;\n    }()\n    /**\n     * Used to simulate throwing a rendering error. Pass an error to throw.\n     *\n     * @param {String} error\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'simulateError',\n    value: function () {\n      function simulateError(error) {\n        var _this13 = this; // in shallow, the \"root\" is the \"rendered\" thing.\n\n\n        return this.single('simulateError', function (thisNode) {\n          if (thisNode.nodeType === 'host') {\n            throw new TypeError('ShallowWrapper::simulateError() can only be called on custom components');\n          }\n\n          var renderer = _this13[RENDERER];\n\n          if (typeof renderer.simulateError !== 'function') {\n            throw new TypeError('your adapter does not support `simulateError`. Try upgrading it!');\n          }\n\n          var rootNode = getRootNodeInternal(_this13);\n          var nodeHierarchy = [thisNode].concat(nodeParents(_this13, thisNode));\n          renderer.simulateError(nodeHierarchy, rootNode, error);\n          return _this13;\n        });\n      }\n\n      return simulateError;\n    }()\n    /**\n     * Returns the props hash for the current node of the wrapper.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'props',\n    value: function () {\n      function props() {\n        return this.single('props', _RSTTraversal.propsOfNode);\n      }\n\n      return props;\n    }()\n    /**\n     * Returns the state hash for the root node of the wrapper. Optionally pass in a prop name and it\n     * will return just that value.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @param {String} name (optional)\n     * @returns {*}\n     */\n\n  }, {\n    key: 'state',\n    value: function () {\n      function state(name) {\n        var _this14 = this;\n\n        if (this[ROOT] !== this) {\n          throw new Error('ShallowWrapper::state() can only be called on the root');\n        }\n\n        if (this.instance() === null || this[RENDERER].getNode().nodeType !== 'class') {\n          throw new Error('ShallowWrapper::state() can only be called on class components');\n        }\n\n        var _state = this.single('state', function () {\n          return _this14.instance().state;\n        });\n\n        if (typeof name !== 'undefined') {\n          if (_state == null) {\n            throw new TypeError('ShallowWrapper::state(\"' + String(name) + '\") requires that `state` not be `null` or `undefined`');\n          }\n\n          return _state[name];\n        }\n\n        return _state;\n      }\n\n      return state;\n    }()\n    /**\n     * Returns the context hash for the root node of the wrapper.\n     * Optionally pass in a prop name and it will return just that value.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @param {String} name (optional)\n     * @returns {*}\n     */\n\n  }, {\n    key: 'context',\n    value: function () {\n      function context(name) {\n        var _this15 = this;\n\n        if (this[ROOT] !== this) {\n          throw new Error('ShallowWrapper::context() can only be called on the root');\n        }\n\n        if (!this[OPTIONS].context) {\n          throw new Error('ShallowWrapper::context() can only be called on a wrapper that was originally passed a context option');\n        }\n\n        if (this.instance() === null) {\n          throw new Error('ShallowWrapper::context() can only be called on wrapped nodes that have a non-null instance');\n        }\n\n        var _context = this.single('context', function () {\n          return _this15.instance().context;\n        });\n\n        if (name) {\n          return _context[name];\n        }\n\n        return _context;\n      }\n\n      return context;\n    }()\n    /**\n     * Returns a new wrapper with all of the children of the current wrapper.\n     *\n     * @param {EnzymeSelector} [selector]\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'children',\n    value: function () {\n      function children(selector) {\n        var allChildren = this.flatMap(function (n) {\n          return (0, _RSTTraversal.childrenOfNode)(n.getNodeInternal());\n        });\n        return selector ? allChildren.filter(selector) : allChildren;\n      }\n\n      return children;\n    }()\n    /**\n     * Returns a new wrapper with a specific child\n     *\n     * @param {Number} [index]\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'childAt',\n    value: function () {\n      function childAt(index) {\n        var _this16 = this;\n\n        return this.single('childAt', function () {\n          return _this16.children().at(index);\n        });\n      }\n\n      return childAt;\n    }()\n    /**\n     * Returns a wrapper around all of the parents/ancestors of the wrapper. Does not include the node\n     * in the current wrapper.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @param {EnzymeSelector} [selector]\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'parents',\n    value: function () {\n      function parents(selector) {\n        var _this17 = this;\n\n        return this.single('parents', function (n) {\n          var allParents = _this17.wrap(nodeParents(_this17, n));\n\n          return selector ? allParents.filter(selector) : allParents;\n        });\n      }\n\n      return parents;\n    }()\n    /**\n     * Returns a wrapper around the immediate parent of the current node.\n     *\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'parent',\n    value: function () {\n      function parent() {\n        return this.flatMap(function (n) {\n          return [n.parents().get(0)];\n        });\n      }\n\n      return parent;\n    }()\n    /**\n     *\n     * @param {EnzymeSelector} selector\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'closest',\n    value: function () {\n      function closest(selector) {\n        if (this.is(selector)) {\n          return this;\n        }\n\n        var matchingAncestors = this.parents().filter(selector);\n        return matchingAncestors.length > 0 ? matchingAncestors.first() : this.findWhere(function () {\n          return false;\n        });\n      }\n\n      return closest;\n    }()\n    /**\n     * Shallow renders the current node and returns a shallow wrapper around it.\n     *\n     * NOTE: can only be called on wrapper of a single node.\n     *\n     * @param {Object} options\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'shallow',\n    value: function () {\n      function shallow() {\n        var _this18 = this;\n\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return this.single('shallow', function (n) {\n          var childOptions = makeInheritedChildOptions(_this18, options);\n          return _this18.wrap((0, _getAdapter2['default'])(_this18[OPTIONS]).nodeToElement(n), null, childOptions);\n        });\n      }\n\n      return shallow;\n    }()\n    /**\n     * Returns the value of prop with the given name of the current node.\n     *\n     * @param propName\n     * @returns {*}\n     */\n\n  }, {\n    key: 'prop',\n    value: function () {\n      function prop(propName) {\n        return this.props()[propName];\n      }\n\n      return prop;\n    }()\n    /**\n     * Used to invoke a function prop.\n     * Will invoke an function prop and return its value.\n     *\n     * @param {String} propName\n     * @returns {Any}\n     */\n\n  }, {\n    key: 'invoke',\n    value: function () {\n      function invoke(propName) {\n        var _this19 = this;\n\n        return this.single('invoke', function () {\n          var handler = _this19.prop(propName);\n\n          if (typeof handler !== 'function') {\n            throw new TypeError('ShallowWrapper::invoke() requires the name of a prop whose value is a function');\n          }\n\n          return function () {\n            var response = handler.apply(undefined, arguments);\n\n            _this19[ROOT].update();\n\n            return response;\n          };\n        });\n      }\n\n      return invoke;\n    }()\n    /**\n     * Returns a wrapper of the node rendered by the provided render prop.\n     *\n     * @param {String} propName\n     * @returns {Function}\n     */\n\n  }, {\n    key: 'renderProp',\n    value: function () {\n      function renderProp(propName) {\n        var _this20 = this;\n\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n\n        if (typeof adapter.wrap !== 'function') {\n          throw new RangeError('your adapter does not support `wrap`. Try upgrading it!');\n        }\n\n        return this.single('renderProp', function (n) {\n          if (n.nodeType === 'host') {\n            throw new TypeError('ShallowWrapper::renderProp() can only be called on custom components');\n          }\n\n          if (typeof propName !== 'string') {\n            throw new TypeError('ShallowWrapper::renderProp(): `propName` must be a string');\n          }\n\n          var props = _this20.props();\n\n          if (!(0, _has2['default'])(props, propName)) {\n            throw new Error('ShallowWrapper::renderProp(): no prop called \\u201C' + String(propName) + '\\u201C found');\n          }\n\n          var propValue = props[propName];\n\n          if (typeof propValue !== 'function') {\n            throw new TypeError('ShallowWrapper::renderProp(): expected prop \\u201C' + String(propName) + '\\u201C to contain a function, but it holds \\u201C' + (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) + '\\u201C');\n          }\n\n          return function () {\n            var element = propValue.apply(undefined, arguments);\n            var wrapped = adapter.wrap(element);\n            return _this20.wrap(wrapped, null, _this20[OPTIONS]);\n          };\n        });\n      }\n\n      return renderProp;\n    }()\n    /**\n     * Returns the key assigned to the current node.\n     *\n     * @returns {String}\n     */\n\n  }, {\n    key: 'key',\n    value: function () {\n      function key() {\n        return this.single('key', function (n) {\n          return n.key === undefined ? null : n.key;\n        });\n      }\n\n      return key;\n    }()\n    /**\n     * Returns the type of the current node of this wrapper. If it's a composite component, this will\n     * be the component constructor. If it's a native DOM node, it will be a string of the tag name.\n     * If it's null, it will be null.\n     *\n     * @returns {String|Function|null}\n     */\n\n  }, {\n    key: 'type',\n    value: function () {\n      function type() {\n        return this.single('type', function (n) {\n          return (0, _Utils.typeOfNode)(n);\n        });\n      }\n\n      return type;\n    }()\n    /**\n     * Returns the name of the current node of this wrapper.\n     *\n     * In order of precedence => type.displayName -> type.name -> type.\n     *\n     * @returns {String}\n     */\n\n  }, {\n    key: 'name',\n    value: function () {\n      function name() {\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n        return this.single('name', function (n) {\n          return adapter.displayNameOfNode ? adapter.displayNameOfNode(n) : (0, _Utils.displayNameOfNode)(n);\n        });\n      }\n\n      return name;\n    }()\n    /**\n     * Returns whether or not the current node has the given class name or not.\n     *\n     * NOTE: can only be called on a wrapper of a single node.\n     *\n     * @param className\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'hasClass',\n    value: function () {\n      function hasClass(className) {\n        if (typeof className === 'string' && className.indexOf('.') !== -1) {\n          // eslint-disable-next-line no-console\n          console.warn('It looks like you\\'re calling `ShallowWrapper::hasClass()` with a CSS selector. hasClass() expects a class name, not a CSS selector.');\n        }\n\n        return this.single('hasClass', function (n) {\n          return (0, _RSTTraversal.hasClassName)(n, className);\n        });\n      }\n\n      return hasClass;\n    }()\n    /**\n     * Iterates through each node of the current wrapper and executes the provided function with a\n     * wrapper around the corresponding node passed in as the first argument.\n     *\n     * @param {Function} fn\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'forEach',\n    value: function () {\n      function forEach(fn) {\n        var _this21 = this;\n\n        this.getNodesInternal().forEach(function (n, i) {\n          return fn.call(_this21, _this21.wrap(n), i);\n        });\n        return this;\n      }\n\n      return forEach;\n    }()\n    /**\n     * Maps the current array of nodes to another array. Each node is passed in as a `ShallowWrapper`\n     * to the map function.\n     *\n     * @param {Function} fn\n     * @returns {Array}\n     */\n\n  }, {\n    key: 'map',\n    value: function () {\n      function map(fn) {\n        var _this22 = this;\n\n        return this.getNodesInternal().map(function (n, i) {\n          return fn.call(_this22, _this22.wrap(n), i);\n        });\n      }\n\n      return map;\n    }()\n    /**\n     * Reduces the current array of nodes to a value. Each node is passed in as a `ShallowWrapper`\n     * to the reducer function.\n     *\n     * @param {Function} fn - the reducer function\n     * @param {*} initialValue - the initial value\n     * @returns {*}\n     */\n\n  }, {\n    key: 'reduce',\n    value: function () {\n      function reduce(fn) {\n        var _this23 = this;\n\n        var initialValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n        if (arguments.length > 1) {\n          return this.getNodesInternal().reduce(function (accum, n, i) {\n            return fn.call(_this23, accum, _this23.wrap(n), i);\n          }, initialValue);\n        }\n\n        return this.getNodesInternal().reduce(function (accum, n, i) {\n          return fn.call(_this23, i === 1 ? _this23.wrap(accum) : accum, _this23.wrap(n), i);\n        });\n      }\n\n      return reduce;\n    }()\n    /**\n     * Reduces the current array of nodes to another array, from right to left. Each node is passed\n     * in as a `ShallowWrapper` to the reducer function.\n     *\n     * @param {Function} fn - the reducer function\n     * @param {*} initialValue - the initial value\n     * @returns {*}\n     */\n\n  }, {\n    key: 'reduceRight',\n    value: function () {\n      function reduceRight(fn) {\n        var _this24 = this;\n\n        var initialValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n        if (arguments.length > 1) {\n          return this.getNodesInternal().reduceRight(function (accum, n, i) {\n            return fn.call(_this24, accum, _this24.wrap(n), i);\n          }, initialValue);\n        }\n\n        return this.getNodesInternal().reduceRight(function (accum, n, i) {\n          return fn.call(_this24, i === 1 ? _this24.wrap(accum) : accum, _this24.wrap(n), i);\n        });\n      }\n\n      return reduceRight;\n    }()\n    /**\n     * Returns a new wrapper with a subset of the nodes of the original wrapper, according to the\n     * rules of `Array#slice`.\n     *\n     * @param {Number} begin\n     * @param {Number} end\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'slice',\n    value: function () {\n      function slice(begin, end) {\n        return this.wrap(this.getNodesInternal().slice(begin, end));\n      }\n\n      return slice;\n    }()\n    /**\n     * Returns whether or not any of the nodes in the wrapper match the provided selector.\n     *\n     * @param {EnzymeSelector} selector\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'some',\n    value: function () {\n      function some(selector) {\n        if (this[ROOT] === this) {\n          throw new Error('ShallowWrapper::some() can not be called on the root');\n        }\n\n        var predicate = (0, _selectors.buildPredicate)(selector);\n        return this.getNodesInternal().some(predicate);\n      }\n\n      return some;\n    }()\n    /**\n     * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.\n     *\n     * @param {Function} predicate\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'someWhere',\n    value: function () {\n      function someWhere(predicate) {\n        var _this25 = this;\n\n        return this.getNodesInternal().some(function (n, i) {\n          return predicate.call(_this25, _this25.wrap(n), i);\n        });\n      }\n\n      return someWhere;\n    }()\n    /**\n     * Returns whether or not all of the nodes in the wrapper match the provided selector.\n     *\n     * @param {EnzymeSelector} selector\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'every',\n    value: function () {\n      function every(selector) {\n        var predicate = (0, _selectors.buildPredicate)(selector);\n        return this.getNodesInternal().every(predicate);\n      }\n\n      return every;\n    }()\n    /**\n     * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.\n     *\n     * @param {Function} predicate\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'everyWhere',\n    value: function () {\n      function everyWhere(predicate) {\n        var _this26 = this;\n\n        return this.getNodesInternal().every(function (n, i) {\n          return predicate.call(_this26, _this26.wrap(n), i);\n        });\n      }\n\n      return everyWhere;\n    }()\n    /**\n     * Utility method used to create new wrappers with a mapping function that returns an array of\n     * nodes in response to a single node wrapper. The returned wrapper is a single wrapper around\n     * all of the mapped nodes flattened (and de-duplicated).\n     *\n     * @param {Function} fn\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'flatMap',\n    value: function () {\n      function flatMap(fn) {\n        var _this27 = this;\n\n        var nodes = this.getNodesInternal().map(function (n, i) {\n          return fn.call(_this27, _this27.wrap(n), i);\n        });\n        var flattened = (0, _arrayPrototype2['default'])(nodes, 1);\n        return this.wrap(flattened.filter(Boolean));\n      }\n\n      return flatMap;\n    }()\n    /**\n     * Finds all nodes in the current wrapper nodes' render trees that match the provided predicate\n     * function. The predicate function will receive the nodes inside a ShallowWrapper as its\n     * first argument.\n     *\n     * @param {Function} predicate\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'findWhere',\n    value: function () {\n      function findWhere(predicate) {\n        var _this28 = this;\n\n        return findWhereUnwrapped(this, function (n) {\n          var node = _this28.wrap(n);\n\n          return node.length > 0 && predicate(node);\n        });\n      }\n\n      return findWhere;\n    }()\n    /**\n     * Returns the node at a given index of the current wrapper.\n     *\n     * @param index\n     * @returns {ReactElement}\n     */\n\n  }, {\n    key: 'get',\n    value: function () {\n      function get(index) {\n        return this.getElements()[index];\n      }\n\n      return get;\n    }()\n    /**\n     * Returns a wrapper around the node at a given index of the current wrapper.\n     *\n     * @param index\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'at',\n    value: function () {\n      function at(index) {\n        var nodes = this.getNodesInternal();\n\n        if (index < nodes.length) {\n          return this.wrap(nodes[index]);\n        }\n\n        return this.wrap([]);\n      }\n\n      return at;\n    }()\n    /**\n     * Returns a wrapper around the first node of the current wrapper.\n     *\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'first',\n    value: function () {\n      function first() {\n        return this.at(0);\n      }\n\n      return first;\n    }()\n    /**\n     * Returns a wrapper around the last node of the current wrapper.\n     *\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'last',\n    value: function () {\n      function last() {\n        return this.at(this.length - 1);\n      }\n\n      return last;\n    }()\n    /**\n     * Delegates to exists()\n     *\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    value: function () {\n      function isEmpty() {\n        // eslint-disable-next-line no-console\n        console.warn('Enzyme::Deprecated method isEmpty() called, use exists() instead.');\n        return !this.exists();\n      }\n\n      return isEmpty;\n    }()\n    /**\n     * Returns true if the current wrapper has nodes. False otherwise.\n     * If called with a selector it returns `.find(selector).exists()` instead.\n     *\n     * @param {EnzymeSelector} selector (optional)\n     * @returns {boolean}\n     */\n\n  }, {\n    key: 'exists',\n    value: function () {\n      function exists() {\n        var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        return arguments.length > 0 ? this.find(selector).exists() : this.length > 0;\n      }\n\n      return exists;\n    }()\n    /**\n     * Utility method that throws an error if the current instance has a length other than one.\n     * This is primarily used to enforce that certain methods are only run on a wrapper when it is\n     * wrapping a single node.\n     *\n     * @param fn\n     * @returns {*}\n     */\n\n  }, {\n    key: 'single',\n    value: function () {\n      function single(name, fn) {\n        var fnName = typeof name === 'string' ? name : 'unknown';\n        var callback = typeof fn === 'function' ? fn : name;\n\n        if (this.length !== 1) {\n          throw new Error('Method \\u201C' + fnName + '\\u201D is meant to be run on 1 node. ' + String(this.length) + ' found instead.');\n        }\n\n        return callback.call(this, this.getNodeInternal());\n      }\n\n      return single;\n    }()\n    /**\n     * Helpful utility method to create a new wrapper with the same root as the current wrapper, with\n     * any nodes passed in as the first parameter automatically wrapped.\n     *\n     * @param node\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'wrap',\n    value: function () {\n      function wrap(node) {\n        var root = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this[ROOT];\n\n        if (node instanceof ShallowWrapper) {\n          return node;\n        }\n\n        for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n          args[_key3 - 2] = arguments[_key3];\n        }\n\n        return new (Function.prototype.bind.apply(ShallowWrapper, [null].concat([node, root], args)))();\n      }\n\n      return wrap;\n    }()\n    /**\n     * Returns an HTML-like string of the shallow render for debugging purposes.\n     *\n     * @param {Object} [options] - Property bag of additional options.\n     * @param {boolean} [options.ignoreProps] - if true, props are omitted from the string.\n     * @param {boolean} [options.verbose] - if true, arrays and objects to be verbosely printed.\n     * @returns {String}\n     */\n\n  }, {\n    key: 'debug',\n    value: function () {\n      function debug() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return (0, _Debug.debugNodes)(this.getNodesInternal(), options);\n      }\n\n      return debug;\n    }()\n    /**\n     * Invokes intercepter and returns itself. intercepter is called with itself.\n     * This is helpful when debugging nodes in method chains.\n     * @param fn\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'tap',\n    value: function () {\n      function tap(intercepter) {\n        intercepter(this);\n        return this;\n      }\n\n      return tap;\n    }()\n    /**\n     * Primarily useful for HOCs (higher-order components), this method may only be\n     * run on a single, non-DOM node, and will return the node, shallow-rendered.\n     *\n     * @param {Object} options\n     * @returns {ShallowWrapper}\n     */\n\n  }, {\n    key: 'dive',\n    value: function () {\n      function dive() {\n        var _this29 = this;\n\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n        var name = 'dive';\n        return this.single(name, function (n) {\n          if (n && n.nodeType === 'host') {\n            throw new TypeError('ShallowWrapper::' + name + '() can not be called on Host Components');\n          }\n\n          var el = (0, _getAdapter2['default'])(_this29[OPTIONS]).nodeToElement(n);\n\n          if (!(0, _Utils.isCustomComponentElement)(el, adapter)) {\n            throw new TypeError('ShallowWrapper::' + name + '() can only be called on components');\n          }\n\n          var childOptions = makeInheritedChildOptions(_this29, options);\n          return _this29.wrap(el, null, childOptions);\n        });\n      }\n\n      return dive;\n    }()\n    /**\n     * Strips out all the not host-nodes from the list of nodes\n     *\n     * This method is useful if you want to check for the presence of host nodes\n     * (actually rendered HTML elements) ignoring the React nodes.\n     */\n\n  }, {\n    key: 'hostNodes',\n    value: function () {\n      function hostNodes() {\n        return this.filterWhere(function (n) {\n          return typeof n.type() === 'string';\n        });\n      }\n\n      return hostNodes;\n    }()\n  }]);\n\n  return ShallowWrapper;\n}();\n/**\n * Updates the context of the primary wrapper when the\n * `wrappingComponent` re-renders.\n */\n\n\nfunction updatePrimaryRootContext(wrappingComponent) {\n  var adapter = (0, _getAdapter2['default'])(wrappingComponent[OPTIONS]);\n  var primaryWrapper = wrappingComponent[PRIMARY_WRAPPER];\n  var primaryRenderer = primaryWrapper[RENDERER];\n  var primaryNode = primaryRenderer.getNode();\n\n  var _getContextFromWrappi2 = getContextFromWrappingComponent(wrappingComponent, adapter),\n      legacyContext = _getContextFromWrappi2.legacyContext,\n      providerValues = _getContextFromWrappi2.providerValues;\n\n  var prevProviderValues = primaryWrapper[PROVIDER_VALUES];\n  primaryWrapper.setContext((0, _object2['default'])({}, wrappingComponent[PRIMARY_WRAPPER][OPTIONS].context, legacyContext));\n  primaryWrapper[PROVIDER_VALUES] = new Map([].concat(_toConsumableArray(prevProviderValues), _toConsumableArray(providerValues)));\n\n  if (typeof adapter.isContextConsumer === 'function' && adapter.isContextConsumer(primaryNode.type)) {\n    var Consumer = primaryNode.type; // Adapters with an `isContextConsumer` method will definitely have a `getProviderFromConsumer`\n    // method.\n\n    var Provider = adapter.getProviderFromConsumer(Consumer);\n    var newValue = providerValues.get(Provider);\n    var oldValue = prevProviderValues.get(Provider); // Use referential comparison like React\n\n    if (newValue !== oldValue) {\n      primaryWrapper.rerender();\n    }\n  }\n}\n/**\n * A *special* \"root\" wrapper that represents the component passed as `wrappingComponent`.\n * It is linked to the primary root such that updates to it will update the primary.\n *\n * @class WrappingComponentWrapper\n */\n\n\nvar WrappingComponentWrapper = function (_ShallowWrapper) {\n  _inherits(WrappingComponentWrapper, _ShallowWrapper);\n\n  function WrappingComponentWrapper(nodes, root, RootFinder) {\n    _classCallCheck(this, WrappingComponentWrapper);\n\n    var _this30 = _possibleConstructorReturn(this, (WrappingComponentWrapper.__proto__ || Object.getPrototypeOf(WrappingComponentWrapper)).call(this, nodes));\n\n    (0, _Utils.privateSet)(_this30, PRIMARY_WRAPPER, root);\n    (0, _Utils.privateSet)(_this30, ROOT_FINDER, RootFinder);\n    return _this30;\n  }\n  /**\n   * Like rerender() on ShallowWrapper, except it also does a \"full render\" of\n   * itself and updates the primary ShallowWrapper's context.\n   */\n\n\n  _createClass(WrappingComponentWrapper, [{\n    key: 'rerender',\n    value: function () {\n      function rerender() {\n        var _get2;\n\n        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n          args[_key4] = arguments[_key4];\n        }\n\n        var result = (_get2 = _get(WrappingComponentWrapper.prototype.__proto__ || Object.getPrototypeOf(WrappingComponentWrapper.prototype), 'rerender', this)).call.apply(_get2, [this].concat(args));\n\n        updatePrimaryRootContext(this);\n        return result;\n      }\n\n      return rerender;\n    }()\n    /**\n     * Like setState() on ShallowWrapper, except it also does a \"full render\" of\n     * itself and updates the primary ShallowWrapper's context.\n     */\n\n  }, {\n    key: 'setState',\n    value: function () {\n      function setState() {\n        var _get3;\n\n        for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          args[_key5] = arguments[_key5];\n        }\n\n        var result = (_get3 = _get(WrappingComponentWrapper.prototype.__proto__ || Object.getPrototypeOf(WrappingComponentWrapper.prototype), 'setState', this)).call.apply(_get3, [this].concat(args));\n\n        updatePrimaryRootContext(this);\n        return result;\n      }\n\n      return setState;\n    }() // eslint-disable-next-line class-methods-use-this\n\n  }, {\n    key: 'getWrappingComponent',\n    value: function () {\n      function getWrappingComponent() {\n        throw new Error('ShallowWrapper::getWrappingComponent() can only be called on the root');\n      }\n\n      return getWrappingComponent;\n    }()\n  }]);\n\n  return WrappingComponentWrapper;\n}(ShallowWrapper);\n\nif (_Utils.ITERATOR_SYMBOL) {\n  Object.defineProperty(ShallowWrapper.prototype, _Utils.ITERATOR_SYMBOL, {\n    configurable: true,\n    value: function () {\n      function iterator() {\n        var _ref2;\n\n        var iter = this.getNodesInternal()[_Utils.ITERATOR_SYMBOL]();\n\n        var adapter = (0, _getAdapter2['default'])(this[OPTIONS]);\n        return _ref2 = {}, _defineProperty(_ref2, _Utils.ITERATOR_SYMBOL, function () {\n          return this;\n        }), _defineProperty(_ref2, 'next', function () {\n          function next() {\n            var next = iter.next();\n\n            if (next.done) {\n              return {\n                done: true\n              };\n            }\n\n            return {\n              done: false,\n              value: adapter.nodeToElement(next.value)\n            };\n          }\n\n          return next;\n        }()), _ref2;\n      }\n\n      return iterator;\n    }()\n  });\n}\n\nfunction privateWarning(prop, extraMessage) {\n  Object.defineProperty(ShallowWrapper.prototype, prop, {\n    get: function () {\n      function get() {\n        throw new Error('\\n        Attempted to access ShallowWrapper::' + String(prop) + ', which was previously a private property on\\n        Enzyme ShallowWrapper instances, but is no longer and should not be relied upon.\\n        ' + String(extraMessage) + '\\n      ');\n      }\n\n      return get;\n    }(),\n    enumerable: false,\n    configurable: false\n  });\n}\n\nprivateWarning('node', 'Consider using the getElement() method instead.');\nprivateWarning('nodes', 'Consider using the getElements() method instead.');\nprivateWarning('renderer', '');\nprivateWarning('options', '');\nprivateWarning('complexSelector', '');\nexports['default'] = ShallowWrapper; //# sourceMappingURL=ShallowWrapper.js.map","map":{"version":3,"sources":["../src/ShallowWrapper.js"],"names":["NODE","NODES","RENDERER","UNRENDERED","ROOT","OPTIONS","SET_STATE","ROOT_NODES","CHILD_CONTEXT","WRAPPING_COMPONENT","PRIMARY_WRAPPER","ROOT_FINDER","PROVIDER_VALUES","filter","treeFilter","n","wrapper","lifecycleExperimental","disableLifecycleMethods","enableComponentDidUpdateOnSetState","supportPrevContextArgumentOfComponentDidUpdate","lifecycles","options","hasLegacySetStateArg","hasLegacyPrevContextArg","componentDidUpdate","onSetState","prevContext","originalGDSFP","getDerivedStateFromProps","hasShouldComponentUpdateBug","setState","getChildContext","calledByRenderer","node","getRootNodeInternal","Array","nodes","instance","Component","componentName","console","childContext","Object","key","renderer","adapter","getChildContextSpy","nodeHierarchy","nodeParents","restore","args","sCUResult","originalSCU","nextState","element","deepRender","children","i","found","rootFinder","legacyContext","providerValues","passedOptions","root","wrappedNode","RootFinder","wrappingComponent","wrappingComponentLegacyContext","wrappingComponentProviderValues","getContextFromWrappingComponent","context","ShallowWrapper","validateOptions","makeShallowOptions","getAdapterLifecycles","spyOnGetChildContextInitialRender","mode","renderedNode","privateSetNodes","getRootNode","callback","privateSetChildContext","props","type","state","prevProps","nextContext","shouldRender","shouldComponentUpdateSpy","gDSFP","mockSCUIfgDSFPReturnNonNull","isPureComponent","pureComponentShouldComponentUpdate","snapshot","undefined","arguments","prevState","statePayload","maybeHasUpdate","nodeOrNodes","predicate","nodeEqual","findWhereUnwrapped","rstNode","a","selector","filterWhereUnwrapped","getTextFromNode","html","event","error","thisNode","rootNode","propsOfNode","name","_state","_context","allChildren","index","allParents","matchingAncestors","childOptions","makeInheritedChildOptions","propName","handler","response","propValue","wrapped","className","fn","initialValue","begin","end","flattened","fnName","intercepter","el","primaryWrapper","primaryRenderer","primaryNode","prevProviderValues","Consumer","Provider","newValue","oldValue","WrappingComponentWrapper","result","updatePrimaryRootContext","ITERATOR_SYMBOL","configurable","value","iter","next","done","get","enumerable","privateWarning"],"mappings":"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","sourcesContent":["import flat from 'array.prototype.flat';\nimport has from 'has';\nimport shallowEqual from 'enzyme-shallow-equal';\n\nimport {\n  nodeEqual,\n  nodeMatches,\n  containsChildrenSubArray,\n  withSetStateAllowed,\n  typeOfNode,\n  isReactElementAlike,\n  displayNameOfNode,\n  isCustomComponent,\n  isCustomComponentElement,\n  ITERATOR_SYMBOL,\n  makeOptions,\n  sym,\n  privateSet,\n  cloneElement,\n  spyMethod,\n  isEmptyValue,\n  loadCheerioRoot,\n} from './Utils';\nimport getAdapter from './getAdapter';\nimport { debugNodes } from './Debug';\nimport {\n  propsOfNode,\n  getTextFromNode,\n  hasClassName,\n  childrenOfNode,\n  parentsOfNode,\n  treeFilter,\n} from './RSTTraversal';\nimport { buildPredicate, reduceTreesBySelector } from './selectors';\n\nconst NODE = sym('__node__');\nconst NODES = sym('__nodes__');\nconst RENDERER = sym('__renderer__');\nconst UNRENDERED = sym('__unrendered__');\nconst ROOT = sym('__root__');\nconst OPTIONS = sym('__options__');\nconst SET_STATE = sym('__setState__');\nconst ROOT_NODES = sym('__rootNodes__');\nconst CHILD_CONTEXT = sym('__childContext__');\nconst WRAPPING_COMPONENT = sym('__wrappingComponent__');\nconst PRIMARY_WRAPPER = sym('__primaryWrapper__');\nconst ROOT_FINDER = sym('__rootFinder__');\nconst PROVIDER_VALUES = sym('__providerValues__');\n\n/**\n * Finds all nodes in the current wrapper nodes' render trees that match the provided predicate\n * function.\n *\n * @param {ShallowWrapper} wrapper\n * @param {Function} predicate\n * @param {Function} filter\n * @returns {ShallowWrapper}\n */\nfunction findWhereUnwrapped(wrapper, predicate, filter = treeFilter) {\n  return wrapper.flatMap((n) => filter(n.getNodeInternal(), predicate));\n}\n\n/**\n * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n * the provided predicate function.\n *\n * @param {ShallowWrapper} wrapper\n * @param {Function} predicate\n * @returns {ShallowWrapper}\n */\nfunction filterWhereUnwrapped(wrapper, predicate) {\n  return wrapper.wrap(wrapper.getNodesInternal().filter(predicate).filter(Boolean));\n}\n\n/**\n * Ensure options passed to ShallowWrapper are valid. Throws otherwise.\n * @param {Object} options\n */\nfunction validateOptions(options) {\n  const {\n    lifecycleExperimental,\n    disableLifecycleMethods,\n    enableComponentDidUpdateOnSetState,\n    supportPrevContextArgumentOfComponentDidUpdate,\n    lifecycles,\n  } = options;\n  if (typeof lifecycleExperimental !== 'undefined' && typeof lifecycleExperimental !== 'boolean') {\n    throw new Error('lifecycleExperimental must be either true or false if provided');\n  }\n\n  if (typeof disableLifecycleMethods !== 'undefined' && typeof disableLifecycleMethods !== 'boolean') {\n    throw new Error('disableLifecycleMethods must be either true or false if provided');\n  }\n\n  if (\n    lifecycleExperimental != null\n    && disableLifecycleMethods != null\n    && lifecycleExperimental === disableLifecycleMethods\n  ) {\n    throw new Error('lifecycleExperimental and disableLifecycleMethods cannot be set to the same value');\n  }\n\n  if (\n    typeof enableComponentDidUpdateOnSetState !== 'undefined'\n    && lifecycles.componentDidUpdate\n    && lifecycles.componentDidUpdate.onSetState !== enableComponentDidUpdateOnSetState\n  ) {\n    throw new TypeError('the legacy enableComponentDidUpdateOnSetState option should be matched by `lifecycles: { componentDidUpdate: { onSetState: true } }`, for compatibility');\n  }\n\n  if (\n    typeof supportPrevContextArgumentOfComponentDidUpdate !== 'undefined'\n    && lifecycles.componentDidUpdate\n    && lifecycles.componentDidUpdate.prevContext !== supportPrevContextArgumentOfComponentDidUpdate\n  ) {\n    throw new TypeError('the legacy supportPrevContextArgumentOfComponentDidUpdate option should be matched by `lifecycles: { componentDidUpdate: { prevContext: true } }`, for compatibility');\n  }\n}\n\nfunction getAdapterLifecycles({ options }) {\n  const {\n    lifecycles = {},\n    enableComponentDidUpdateOnSetState,\n    supportPrevContextArgumentOfComponentDidUpdate,\n  } = options;\n\n  const hasLegacySetStateArg = typeof enableComponentDidUpdateOnSetState !== 'undefined';\n  const hasLegacyPrevContextArg = typeof supportPrevContextArgumentOfComponentDidUpdate !== 'undefined';\n  const componentDidUpdate = hasLegacySetStateArg || hasLegacyPrevContextArg\n    ? {\n      ...(hasLegacySetStateArg && {\n        onSetState: !!enableComponentDidUpdateOnSetState,\n      }),\n      ...(hasLegacyPrevContextArg && {\n        prevContext: !!supportPrevContextArgumentOfComponentDidUpdate,\n      }),\n    }\n    : null;\n  const { getDerivedStateFromProps: originalGDSFP } = lifecycles;\n  const getDerivedStateFromProps = originalGDSFP ? {\n    hasShouldComponentUpdateBug: !!originalGDSFP.hasShouldComponentUpdateBug,\n  } : false;\n\n  return {\n    ...lifecycles,\n    setState: {\n      ...lifecycles.setState,\n    },\n    getChildContext: {\n      calledByRenderer: true,\n      ...lifecycles.getChildContext,\n    },\n    ...(componentDidUpdate && { componentDidUpdate }),\n    getDerivedStateFromProps,\n  };\n}\n\nfunction getRootNode(node) {\n  if (node.nodeType === 'host') {\n    return node;\n  }\n  return node.rendered;\n}\n\nfunction getRootNodeInternal(wrapper) {\n  if (wrapper[ROOT].length !== 1) {\n    throw new Error('getRootNodeInternal(wrapper) can only be called when wrapper wraps one node');\n  }\n  if (wrapper[ROOT] !== wrapper) {\n    return wrapper[ROOT_NODES][0];\n  }\n  return wrapper[ROOT][NODE];\n}\n\nfunction nodeParents(wrapper, node) {\n  return parentsOfNode(node, getRootNodeInternal(wrapper));\n}\n\nfunction privateSetNodes(wrapper, nodes) {\n  if (!Array.isArray(nodes)) {\n    privateSet(wrapper, NODE, nodes);\n    privateSet(wrapper, NODES, [nodes]);\n  } else {\n    privateSet(wrapper, NODE, nodes[0]);\n    privateSet(wrapper, NODES, nodes);\n  }\n  privateSet(wrapper, 'length', wrapper[NODES].length);\n}\n\nfunction pureComponentShouldComponentUpdate(prevProps, props, prevState, state) {\n  return !shallowEqual(prevProps, props) || !shallowEqual(prevState, state);\n}\n\nfunction isPureComponent(instance) {\n  return instance && instance.isPureReactComponent;\n}\n\nfunction getChildContext(node, hierarchy, renderer) {\n  const { instance, type: Component } = node;\n  const componentName = displayNameOfNode(node);\n  // Warn like react if childContextTypes is not defined:\n  // https://github.com/facebook/react/blob/1454a8be03794f5e0b23a7e7696cbbbdcf8b0f5d/packages/react-dom/src/server/ReactPartialRenderer.js#L639-L646\n  if (typeof Component.childContextTypes !== 'object') {\n    // eslint-disable-next-line no-console\n    console.warn(\n      `${componentName}.getChildContext(): childContextTypes must be defined in order to use getChildContext().`,\n    );\n    return {};\n  }\n  // Check childContextTypes like react:\n  // https://github.com/facebook/react/blob/1454a8be03794f5e0b23a7e7696cbbbdcf8b0f5d/packages/react-dom/src/server/ReactPartialRenderer.js#L630-L637\n  const childContext = instance.getChildContext();\n  Object.keys(childContext).forEach((key) => {\n    if (!(key in Component.childContextTypes)) {\n      throw new Error(\n        `${componentName}.getChildContext(): key \"${key}\" is not defined in childContextTypes.`,\n      );\n    }\n  });\n  if (typeof renderer.checkPropTypes === 'function') {\n    renderer.checkPropTypes(Component.childContextTypes, childContext, 'child context', hierarchy);\n  }\n  return childContext;\n}\n\nfunction spyOnGetChildContextInitialRender(nodes, adapter) {\n  if (\n    !isCustomComponentElement(nodes, adapter)\n    || !nodes.type.prototype\n    || typeof nodes.type.prototype.getChildContext !== 'function'\n  ) {\n    return null;\n  }\n\n  return spyMethod(nodes.type.prototype, 'getChildContext');\n}\n\nfunction privateSetChildContext(adapter, wrapper, instance, renderedNode, getChildContextSpy) {\n  const renderer = wrapper[RENDERER];\n  // We only support parent-based context.\n  if (adapter.options.legacyContextMode !== 'parent') { return; }\n  if (getChildContextSpy) {\n    privateSet(wrapper, CHILD_CONTEXT, getChildContextSpy.getLastReturnValue());\n    getChildContextSpy.restore();\n  } else if (typeof instance.getChildContext === 'function') {\n    // If there's no spy but getChildContext is a function, that means our renderer\n    // is not going to call it for us, so we need to call it ourselves.\n    const nodeHierarchy = [wrapper[NODE]].concat(nodeParents(wrapper, wrapper[NODE]));\n    const childContext = getChildContext(renderedNode, nodeHierarchy, renderer);\n    privateSet(wrapper, CHILD_CONTEXT, childContext);\n  } else {\n    privateSet(wrapper, CHILD_CONTEXT, null);\n  }\n}\n\nfunction mockSCUIfgDSFPReturnNonNull(node, state) {\n  const { getDerivedStateFromProps } = node.type;\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    // we try to fix a React shallow renderer bug here.\n    // (facebook/react#14607, which has been fixed in react 16.8):\n    // when gDSFP return derived state, it will set instance state in shallow renderer before SCU,\n    // this will cause `this.state` in sCU be the updated state, which is wrong behavior.\n    // so we have to wrap sCU to pass the old state to original sCU.\n    const { instance } = node;\n    const { restore } = spyMethod(\n      instance,\n      'shouldComponentUpdate',\n      (originalSCU) => function shouldComponentUpdate(...args) {\n        instance.state = state;\n        const sCUResult = originalSCU.apply(instance, args);\n        const [, nextState] = args;\n        instance.state = nextState;\n        restore();\n        return sCUResult;\n      },\n    );\n  }\n}\n\n/**\n * Recursively dive()s every custom component in a wrapper until\n * the target component is found.\n *\n * @param {ShallowWrapper} wrapper A ShallowWrapper to search\n * @param {ComponentType} target A react custom component that, when found, will end recursion\n * @param {Adapter} adapter An Enzyme adapter\n * @returns {ShallowWrapper|undefined} A ShallowWrapper for the target, or\n *  undefined if it can't be found\n */\nfunction deepRender(wrapper, target, adapter) {\n  const node = wrapper[NODE];\n  const element = node && adapter.nodeToElement(node);\n  if (wrapper.type() === target) {\n    return wrapper.dive();\n  }\n  if (element && isCustomComponentElement(element, adapter)) {\n    return deepRender(wrapper.dive(), target, adapter);\n  }\n  const children = wrapper.children();\n  for (let i = 0; i < children.length; i += 1) {\n    const found = deepRender(children.at(i), target, adapter);\n    if (typeof found !== 'undefined') {\n      return found;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Deep-renders the `wrappingComponent` and returns the context that should\n * be accessible to the primary wrapper.\n *\n * @param {WrappingComponentWrapper} wrapper The `WrappingComponentWrapper` for a\n *  `wrappingComponent`\n * @param {Adapter} adapter An Enzyme adapter\n * @returns {object} An object containing an object of legacy context values and a Map of\n *  `createContext()` Provider values.\n */\nfunction getContextFromWrappingComponent(wrapper, adapter) {\n  const rootFinder = deepRender(wrapper, wrapper[ROOT_FINDER], adapter);\n  if (!rootFinder) {\n    throw new Error('`wrappingComponent` must render its children!');\n  }\n  return {\n    legacyContext: rootFinder[OPTIONS].context,\n    providerValues: rootFinder[PROVIDER_VALUES],\n  };\n}\n\n/**\n * Makes options specifically for `ShallowWrapper`. Most of the logic here is around rendering\n * a `wrappingComponent` (if one was provided) and adding the child context of that component\n * to `options.context`.\n *\n * @param {ReactElement} nodes the nodes passed to `ShallowWrapper`\n * @param {ShallowWrapper} root this `ShallowWrapper`'s parent. If this is passed, options are\n *  not transformed.\n * @param {*} passedOptions the options passed to `ShallowWrapper`.\n * @param {*} wrapper the `ShallowWrapper` itself\n * @returns {Object} the decorated and transformed options\n */\nfunction makeShallowOptions(nodes, root, passedOptions, wrapper) {\n  const options = makeOptions(passedOptions);\n  const adapter = getAdapter(passedOptions);\n  privateSet(options, PROVIDER_VALUES, passedOptions[PROVIDER_VALUES]);\n  if (root || !isCustomComponent(options.wrappingComponent, adapter)) {\n    return options;\n  }\n  if (typeof adapter.wrapWithWrappingComponent !== 'function') {\n    throw new TypeError('your adapter does not support `wrappingComponent`. Try upgrading it!');\n  }\n  const { node: wrappedNode, RootFinder } = adapter.wrapWithWrappingComponent(nodes, options);\n  // eslint-disable-next-line no-use-before-define\n  const wrappingComponent = new WrappingComponentWrapper(wrappedNode, wrapper, RootFinder);\n  const {\n    legacyContext: wrappingComponentLegacyContext,\n    providerValues: wrappingComponentProviderValues,\n  } = getContextFromWrappingComponent(wrappingComponent, adapter);\n  privateSet(wrapper, WRAPPING_COMPONENT, wrappingComponent);\n  return {\n    ...options,\n    context: {\n      ...options.context,\n      ...wrappingComponentLegacyContext,\n    },\n    [PROVIDER_VALUES]: wrappingComponentProviderValues,\n  };\n}\n\n\nfunction makeInheritedChildOptions(wrapper, options = {}) {\n  const childOptions = {\n    ...wrapper[OPTIONS],\n    ...options,\n    context: options.context || {\n      ...wrapper[OPTIONS].context,\n      ...wrapper[ROOT][CHILD_CONTEXT],\n    },\n  };\n  privateSet(childOptions, PROVIDER_VALUES, wrapper[ROOT][PROVIDER_VALUES]);\n  return childOptions;\n}\n\n\n/**\n * @class ShallowWrapper\n */\nclass ShallowWrapper {\n  constructor(nodes, root, passedOptions = {}) {\n    validateOptions(passedOptions);\n\n    const options = makeShallowOptions(nodes, root, passedOptions, this);\n    const adapter = getAdapter(options);\n    const lifecycles = getAdapterLifecycles(adapter);\n\n    // mounting a ShallowRender component\n    if (!root) {\n      if (!adapter.isValidElement(nodes)) {\n        throw new TypeError('ShallowWrapper can only wrap valid elements');\n      }\n\n      const getChildContextSpy = lifecycles.getChildContext.calledByRenderer\n        ? spyOnGetChildContextInitialRender(nodes, adapter)\n        : null;\n      privateSet(this, ROOT, this);\n      privateSet(this, UNRENDERED, nodes);\n      const renderer = adapter.createRenderer({ mode: 'shallow', ...options });\n      privateSet(this, RENDERER, renderer);\n      const providerValues = new Map(options[PROVIDER_VALUES] || []);\n      this[RENDERER].render(nodes, options.context, { providerValues });\n      const renderedNode = this[RENDERER].getNode();\n      privateSetNodes(this, getRootNode(renderedNode));\n      privateSet(this, OPTIONS, options);\n      privateSet(this, PROVIDER_VALUES, providerValues);\n\n      const { instance } = renderedNode;\n      if (instance && !options.disableLifecycleMethods) {\n        // Ensure to call componentDidUpdate when instance.setState is called\n        if (lifecycles.componentDidUpdate.onSetState && !instance[SET_STATE]) {\n          privateSet(instance, SET_STATE, instance.setState);\n          instance.setState = (updater, callback = undefined) => this.setState(\n            ...(callback == null ? [updater] : [updater, callback]),\n          );\n        }\n\n        if (typeof instance.componentDidMount === 'function') {\n          this[RENDERER].batchedUpdates(() => {\n            instance.componentDidMount();\n          });\n        }\n        privateSetChildContext(adapter, this, instance, renderedNode, getChildContextSpy);\n      }\n    // creating a child component through enzyme's ShallowWrapper APIs.\n    } else {\n      privateSet(this, ROOT, root);\n      privateSet(this, UNRENDERED, null);\n      privateSet(this, RENDERER, root[RENDERER]);\n      privateSetNodes(this, nodes);\n      privateSet(this, OPTIONS, root[OPTIONS]);\n      privateSet(this, ROOT_NODES, root[NODES]);\n      privateSet(this, PROVIDER_VALUES, null);\n    }\n  }\n\n  /**\n   * Returns the root wrapper\n   *\n   * @return {ShallowWrapper}\n   */\n  root() {\n    return this[ROOT];\n  }\n\n  /**\n   * Returns the wrapped component.\n   *\n   * @return {ReactComponent}\n   */\n  getNodeInternal() {\n    if (this.length !== 1) {\n      throw new Error('ShallowWrapper::getNode() can only be called when wrapping one node');\n    }\n    if (this[ROOT] === this) {\n      this.update();\n    }\n    return this[NODE];\n  }\n\n  /**\n   * Returns the the wrapped components.\n   *\n   * @return {Array<ReactComponent>}\n   */\n  getNodesInternal() {\n    if (this[ROOT] === this && this.length === 1) {\n      this.update();\n    }\n    return this[NODES];\n  }\n\n  /**\n   * Returns the wrapped ReactElement.\n   *\n   * @return {ReactElement}\n   */\n  getElement() {\n    return this.single('getElement', (n) => getAdapter(this[OPTIONS]).nodeToElement(n));\n  }\n\n  /**\n   * Returns the wrapped ReactElements.\n   *\n   * @return {Array<ReactElement>}\n   */\n  getElements() {\n    return this.getNodesInternal().map((n) => getAdapter(this[OPTIONS]).nodeToElement(n));\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  getNode() {\n    throw new Error('ShallowWrapper::getNode() is no longer supported. Use ShallowWrapper::getElement() instead');\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  getNodes() {\n    throw new Error('ShallowWrapper::getNodes() is no longer supported. Use ShallowWrapper::getElements() instead');\n  }\n\n  /**\n   * Gets the instance of the component being rendered as the root node passed into `shallow()`.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * Example:\n   * ```\n   * const wrapper = shallow(<MyComponent />);\n   * const inst = wrapper.instance();\n   * expect(inst).to.be.instanceOf(MyComponent);\n   * ```\n   * @returns {ReactComponent}\n   */\n  instance() {\n    if (this[ROOT] !== this) {\n      throw new Error('ShallowWrapper::instance() can only be called on the root');\n    }\n    return this[RENDERER].getNode().instance;\n  }\n\n  /**\n   * If a `wrappingComponent` was passed in `options`, this methods returns a `ShallowWrapper`\n   * around the rendered `wrappingComponent`. This `ShallowWrapper` can be used to update the\n   * `wrappingComponent`'s props, state, etc.\n   *\n   * @returns ShallowWrapper\n   */\n  getWrappingComponent() {\n    if (this[ROOT] !== this) {\n      throw new Error('ShallowWrapper::getWrappingComponent() can only be called on the root');\n    }\n    if (!this[OPTIONS].wrappingComponent) {\n      throw new Error('ShallowWrapper::getWrappingComponent() can only be called on a wrapper that was originally passed a `wrappingComponent` option');\n    }\n    return this[WRAPPING_COMPONENT];\n  }\n\n  /**\n   * Forces a re-render. Useful to run before checking the render output if something external\n   * may be updating the state of the component somewhere.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @returns {ShallowWrapper}\n   */\n  update() {\n    if (this[ROOT] !== this) {\n      throw new Error('ShallowWrapper::update() can only be called on the root');\n    }\n    if (this.length !== 1) {\n      throw new Error('ShallowWrapper::update() can only be called when wrapping one node');\n    }\n    privateSetNodes(this, getRootNode(this[RENDERER].getNode()));\n    return this;\n  }\n\n  /**\n   * A method that unmounts the component. This can be used to simulate a component going through\n   * and unmount/mount lifecycle.\n   * @returns {ShallowWrapper}\n   */\n  unmount() {\n    this[RENDERER].unmount();\n    if (this[ROOT][WRAPPING_COMPONENT]) {\n      this[ROOT][WRAPPING_COMPONENT].unmount();\n    }\n    return this;\n  }\n\n  /**\n   * A method is for re-render with new props and context.\n   * This calls componentDidUpdate method if disableLifecycleMethods is not enabled.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @param {Object} props\n   * @param {Object} context\n   * @returns {ShallowWrapper}\n   */\n  rerender(props, context) {\n    const adapter = getAdapter(this[OPTIONS]);\n    this.single('rerender', () => {\n      withSetStateAllowed(() => {\n        // NOTE(lmr): In react 16, instances will be null for SFCs, but\n        // rerendering with props/context is still a valid thing to do. In\n        // this case, state will be undefined, but props/context will exist.\n        const node = this[RENDERER].getNode();\n        const instance = node.instance || {};\n        const type = node.type || {};\n        const { state } = instance;\n        const prevProps = instance.props || this[UNRENDERED].props;\n        const prevContext = instance.context || this[OPTIONS].context;\n        const nextContext = context || prevContext;\n        if (context) {\n          this[OPTIONS] = { ...this[OPTIONS], context: nextContext };\n        }\n        this[RENDERER].batchedUpdates(() => {\n          // When shouldComponentUpdate returns false we shouldn't call componentDidUpdate.\n          // so we spy shouldComponentUpdate to get the result.\n          const lifecycles = getAdapterLifecycles(adapter);\n          let shouldRender = true;\n          let shouldComponentUpdateSpy;\n          let getChildContextSpy;\n          if (\n            !this[OPTIONS].disableLifecycleMethods\n            && instance\n          ) {\n            if (typeof instance.shouldComponentUpdate === 'function') {\n              const { getDerivedStateFromProps: gDSFP } = lifecycles;\n              if (gDSFP && gDSFP.hasShouldComponentUpdateBug) {\n                mockSCUIfgDSFPReturnNonNull(node, state);\n              }\n              shouldComponentUpdateSpy = spyMethod(instance, 'shouldComponentUpdate');\n            }\n            if (\n              lifecycles.getChildContext.calledByRenderer\n              && typeof instance.getChildContext === 'function'\n            ) {\n              getChildContextSpy = spyMethod(instance, 'getChildContext');\n            }\n          }\n          if (!shouldComponentUpdateSpy && isPureComponent(instance)) {\n            shouldRender = pureComponentShouldComponentUpdate(\n              prevProps,\n              props,\n              state,\n              instance.state,\n            );\n          }\n          if (props) this[UNRENDERED] = cloneElement(adapter, this[UNRENDERED], props);\n          this[RENDERER].render(this[UNRENDERED], nextContext, {\n            providerValues: this[PROVIDER_VALUES],\n          });\n          if (shouldComponentUpdateSpy) {\n            shouldRender = shouldComponentUpdateSpy.getLastReturnValue();\n            shouldComponentUpdateSpy.restore();\n          }\n          if (\n            shouldRender\n            && !this[OPTIONS].disableLifecycleMethods\n            && instance\n          ) {\n            privateSetChildContext(adapter, this, instance, node, getChildContextSpy);\n            if (lifecycles.getSnapshotBeforeUpdate) {\n              let snapshot;\n              if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n                snapshot = instance.getSnapshotBeforeUpdate(prevProps, state);\n              }\n              if (\n                lifecycles.componentDidUpdate\n                && typeof instance.componentDidUpdate === 'function'\n                && (\n                  !state\n                  || shallowEqual(state, this.instance().state)\n                  || typeof type.getDerivedStateFromProps === 'function'\n                )\n              ) {\n                instance.componentDidUpdate(prevProps, state, snapshot);\n              }\n            } else if (\n              lifecycles.componentDidUpdate\n              && typeof instance.componentDidUpdate === 'function'\n            ) {\n              if (lifecycles.componentDidUpdate.prevContext) {\n                instance.componentDidUpdate(prevProps, state, prevContext);\n              } else if (!state || shallowEqual(this.instance().state, state)) {\n                instance.componentDidUpdate(prevProps, state);\n              }\n            }\n          // If it doesn't need to rerender, update only its props.\n          } else if (!shallowEqual(props, instance.props)) {\n            instance.props = (Object.freeze || Object)({ ...instance.props, ...props });\n          }\n          this.update();\n        });\n      });\n    });\n    return this;\n  }\n\n  /**\n   * A method that sets the props of the root component, and re-renders. Useful for when you are\n   * wanting to test how the component behaves over time with changing props. Calling this, for\n   * instance, will call the `componentWillReceiveProps` lifecycle method.\n   *\n   * Similar to `setState`, this method accepts a props object and will merge it in with the already\n   * existing props.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @param {Object} props object\n   * @param {Function} cb - callback function\n   * @returns {ShallowWrapper}\n   */\n  setProps(props, callback = undefined) {\n    if (this[ROOT] !== this) {\n      throw new Error('ShallowWrapper::setProps() can only be called on the root');\n    }\n    if (arguments.length > 1 && typeof callback !== 'function') {\n      throw new TypeError('ReactWrapper::setProps() expects a function as its second argument');\n    }\n    this.rerender(props);\n    if (callback) {\n      callback();\n    }\n    return this;\n  }\n\n  /**\n   * A method to invoke `setState` on the root component instance similar to how you might in the\n   * definition of the component, and re-renders.  This method is useful for testing your component\n   * in hard to achieve states, however should be used sparingly. If possible, you should utilize\n   * your component's external API in order to get it into whatever state you want to test, in order\n   * to be as accurate of a test as possible. This is not always practical, however.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @param {Object} state to merge\n   * @param {Function} cb - callback function\n   * @returns {ShallowWrapper}\n   */\n  setState(state, callback = undefined) {\n    if (this[ROOT] !== this) {\n      throw new Error('ShallowWrapper::setState() can only be called on the root');\n    }\n    if (this.instance() === null || this[RENDERER].getNode().nodeType !== 'class') {\n      throw new Error('ShallowWrapper::setState() can only be called on class components');\n    }\n    if (arguments.length > 1 && typeof callback !== 'function') {\n      throw new TypeError('ReactWrapper::setState() expects a function as its second argument');\n    }\n\n    this.single('setState', () => {\n      withSetStateAllowed(() => {\n        const adapter = getAdapter(this[OPTIONS]);\n\n        const lifecycles = getAdapterLifecycles(adapter);\n\n        const node = this[RENDERER].getNode();\n        const { instance } = node;\n        const prevProps = instance.props;\n        const prevState = instance.state;\n        const prevContext = instance.context;\n\n        const statePayload = typeof state === 'function'\n          ? state.call(instance, prevState, prevProps)\n          : state;\n\n        // returning null or undefined prevents the update in React 16+\n        // https://github.com/facebook/react/pull/12756\n        const maybeHasUpdate = !lifecycles.setState.skipsComponentDidUpdateOnNullish\n          || statePayload != null;\n\n        // When shouldComponentUpdate returns false we shouldn't call componentDidUpdate.\n        // so we spy shouldComponentUpdate to get the result.\n        let shouldComponentUpdateSpy;\n        let getChildContextSpy;\n        let shouldRender = true;\n        if (\n          !this[OPTIONS].disableLifecycleMethods\n          && instance\n        ) {\n          if (\n            lifecycles.componentDidUpdate\n            && lifecycles.componentDidUpdate.onSetState\n            && typeof instance.shouldComponentUpdate === 'function'\n          ) {\n            const { getDerivedStateFromProps: gDSFP } = lifecycles;\n            if (gDSFP && gDSFP.hasShouldComponentUpdateBug) {\n              mockSCUIfgDSFPReturnNonNull(node, state);\n            }\n            shouldComponentUpdateSpy = spyMethod(instance, 'shouldComponentUpdate');\n          }\n          if (\n            lifecycles.getChildContext.calledByRenderer\n            && typeof instance.getChildContext === 'function'\n          ) {\n            getChildContextSpy = spyMethod(instance, 'getChildContext');\n          }\n        }\n        if (!shouldComponentUpdateSpy && isPureComponent(instance)) {\n          shouldRender = pureComponentShouldComponentUpdate(\n            prevProps,\n            instance.props,\n            prevState,\n            { ...prevState, ...statePayload },\n          );\n        }\n\n        // We don't pass the setState callback here\n        // to guarantee to call the callback after finishing the render\n        if (instance[SET_STATE]) {\n          instance[SET_STATE](statePayload);\n        } else {\n          instance.setState(statePayload);\n        }\n        if (shouldComponentUpdateSpy) {\n          shouldRender = shouldComponentUpdateSpy.getLastReturnValue();\n          shouldComponentUpdateSpy.restore();\n        }\n        if (\n          maybeHasUpdate\n          && shouldRender\n          && !this[OPTIONS].disableLifecycleMethods\n        ) {\n          privateSetChildContext(adapter, this, instance, node, getChildContextSpy);\n          if (\n            lifecycles.componentDidUpdate\n            && lifecycles.componentDidUpdate.onSetState\n          ) {\n            if (\n              lifecycles.getSnapshotBeforeUpdate\n              && typeof instance.getSnapshotBeforeUpdate === 'function'\n            ) {\n              const snapshot = instance.getSnapshotBeforeUpdate(prevProps, prevState);\n              if (typeof instance.componentDidUpdate === 'function') {\n                instance.componentDidUpdate(prevProps, prevState, snapshot);\n              }\n            } else if (typeof instance.componentDidUpdate === 'function') {\n              if (lifecycles.componentDidUpdate.prevContext) {\n                instance.componentDidUpdate(prevProps, prevState, prevContext);\n              } else {\n                instance.componentDidUpdate(prevProps, prevState);\n              }\n            }\n          }\n        }\n        this.update();\n        // call the setState callback\n        if (callback) {\n          if (adapter.invokeSetStateCallback) {\n            adapter.invokeSetStateCallback(instance, callback);\n          } else {\n            callback.call(instance);\n          }\n        }\n      });\n    });\n    return this;\n  }\n\n  /**\n   * A method that sets the context of the root component, and re-renders. Useful for when you are\n   * wanting to test how the component behaves over time with changing contexts.\n   *\n   * NOTE: can only be called on a wrapper instance that is also the root instance.\n   *\n   * @param {Object} context object\n   * @returns {ShallowWrapper}\n   */\n  setContext(context) {\n    if (this[ROOT] !== this) {\n      throw new Error('ShallowWrapper::setContext() can only be called on the root');\n    }\n    if (!this[OPTIONS].context) {\n      throw new Error('ShallowWrapper::setContext() can only be called on a wrapper that was originally passed a context option');\n    }\n    return this.rerender(null, context);\n  }\n\n  /**\n   * Whether or not a given react element exists in the shallow render tree.\n   *\n   * Example:\n   * ```\n   * const wrapper = shallow(<MyComponent />);\n   * expect(wrapper.contains(<div className=\"foo bar\" />)).to.equal(true);\n   * ```\n   *\n   * @param {ReactElement|Array<ReactElement>} nodeOrNodes\n   * @returns {Boolean}\n   */\n  contains(nodeOrNodes) {\n    const adapter = getAdapter(this[OPTIONS]);\n    if (!isReactElementAlike(nodeOrNodes, adapter)) {\n      throw new Error('ShallowWrapper::contains() can only be called with a ReactElement (or an array of them), a string, or a number as an argument.');\n    }\n    const predicate = Array.isArray(nodeOrNodes)\n      ? (other) => containsChildrenSubArray(\n        nodeEqual,\n        other,\n        nodeOrNodes.map((node) => adapter.elementToNode(node)),\n      )\n      : (other) => nodeEqual(adapter.elementToNode(nodeOrNodes), other);\n\n    return findWhereUnwrapped(this, predicate).length > 0;\n  }\n\n  /**\n   * Whether or not a given react element exists in the shallow render tree.\n   * Match is based on the expected element and not on wrappers element.\n   * It will determine if one of the wrappers element \"looks like\" the expected\n   * element by checking if all props of the expected element are present\n   * on the wrappers element and equals to each other.\n   *\n   * Example:\n   * ```\n   * // MyComponent outputs <div><div class=\"foo\">Hello</div></div>\n   * const wrapper = shallow(<MyComponent />);\n   * expect(wrapper.containsMatchingElement(<div>Hello</div>)).to.equal(true);\n   * ```\n   *\n   * @param {ReactElement} node\n   * @returns {Boolean}\n   */\n  containsMatchingElement(node) {\n    const adapter = getAdapter(this[OPTIONS]);\n    const rstNode = adapter.elementToNode(node);\n    const predicate = (other) => nodeMatches(rstNode, other, (a, b) => a <= b);\n    return findWhereUnwrapped(this, predicate).length > 0;\n  }\n\n  /**\n   * Whether or not all the given react elements exist in the shallow render tree.\n   * Match is based on the expected element and not on wrappers element.\n   * It will determine if one of the wrappers element \"looks like\" the expected\n   * element by checking if all props of the expected element are present\n   * on the wrappers element and equals to each other.\n   *\n   * Example:\n   * ```\n   * const wrapper = shallow(<MyComponent />);\n   * expect(wrapper.containsAllMatchingElements([\n   *   <div>Hello</div>,\n   *   <div>Goodbye</div>,\n   * ])).to.equal(true);\n   * ```\n   *\n   * @param {Array<ReactElement>} nodes\n   * @returns {Boolean}\n   */\n  containsAllMatchingElements(nodes) {\n    if (!Array.isArray(nodes)) {\n      throw new TypeError('nodes should be an Array');\n    }\n\n    return nodes.every((node) => this.containsMatchingElement(node));\n  }\n\n  /**\n   * Whether or not one of the given react elements exists in the shallow render tree.\n   * Match is based on the expected element and not on wrappers element.\n   * It will determine if one of the wrappers element \"looks like\" the expected\n   * element by checking if all props of the expected element are present\n   * on the wrappers element and equals to each other.\n   *\n   * Example:\n   * ```\n   * const wrapper = shallow(<MyComponent />);\n   * expect(wrapper.containsAnyMatchingElements([\n   *   <div>Hello</div>,\n   *   <div>Goodbye</div>,\n   * ])).to.equal(true);\n   * ```\n   *\n   * @param {Array<ReactElement>} nodes\n   * @returns {Boolean}\n   */\n  containsAnyMatchingElements(nodes) {\n    return Array.isArray(nodes) && nodes.some((node) => this.containsMatchingElement(node));\n  }\n\n  /**\n   * Whether or not a given react element exists in the render tree.\n   *\n   * Example:\n   * ```\n   * const wrapper = shallow(<MyComponent />);\n   * expect(wrapper.contains(<div className=\"foo bar\" />)).to.equal(true);\n   * ```\n   *\n   * @param {ReactElement} node\n   * @returns {Boolean}\n   */\n  equals(node) {\n    return this.single('equals', () => nodeEqual(this.getNodeInternal(), node));\n  }\n\n  /**\n   * Whether or not a given react element matches the render tree.\n   * Match is based on the expected element and not on wrapper root node.\n   * It will determine if the wrapper root node \"looks like\" the expected\n   * element by checking if all props of the expected element are present\n   * on the wrapper root node and equals to each other.\n   *\n   * Example:\n   * ```\n   * // MyComponent outputs <div class=\"foo\">Hello</div>\n   * const wrapper = shallow(<MyComponent />);\n   * expect(wrapper.matchesElement(<div>Hello</div>)).to.equal(true);\n   * ```\n   *\n   * @param {ReactElement} node\n   * @returns {Boolean}\n   */\n  matchesElement(node) {\n    return this.single('matchesElement', () => {\n      const adapter = getAdapter(this[OPTIONS]);\n      const rstNode = adapter.elementToNode(node);\n      return nodeMatches(rstNode, this.getNodeInternal(), (a, b) => a <= b);\n    });\n  }\n\n  /**\n   * Finds every node in the render tree of the current wrapper that matches the provided selector.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {ShallowWrapper}\n   */\n  find(selector) {\n    return this.wrap(reduceTreesBySelector(selector, this.getNodesInternal()));\n  }\n\n  /**\n   * Returns whether or not current node matches a provided selector.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {boolean}\n   */\n  is(selector) {\n    const predicate = buildPredicate(selector);\n    return this.single('is', (n) => predicate(n));\n  }\n\n  /**\n   * Returns true if the component rendered nothing, i.e., null or false.\n   *\n   * @returns {boolean}\n   */\n  isEmptyRender() {\n    const nodes = this.getNodesInternal();\n\n    return nodes.every((n) => isEmptyValue(n));\n  }\n\n  /**\n   * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n   * the provided predicate function. The predicate should receive a wrapped node as its first\n   * argument.\n   *\n   * @param {Function} predicate\n   * @returns {ShallowWrapper}\n   */\n  filterWhere(predicate) {\n    return filterWhereUnwrapped(this, (n) => predicate(this.wrap(n)));\n  }\n\n  /**\n   * Returns a new wrapper instance with only the nodes of the current wrapper instance that match\n   * the provided selector.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {ShallowWrapper}\n   */\n  filter(selector) {\n    const predicate = buildPredicate(selector);\n    return filterWhereUnwrapped(this, predicate);\n  }\n\n  /**\n   * Returns a new wrapper instance with only the nodes of the current wrapper that did not match\n   * the provided selector. Essentially the inverse of `filter`.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {ShallowWrapper}\n   */\n  not(selector) {\n    const predicate = buildPredicate(selector);\n    return filterWhereUnwrapped(this, (n) => !predicate(n));\n  }\n\n  /**\n   * Returns a string of the rendered text of the current render tree.  This function should be\n   * looked at with skepticism if being used to test what the actual HTML output of the component\n   * will be. If that is what you would like to test, use enzyme's `render` function instead.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {String}\n   */\n  text() {\n    return this.single('text', getTextFromNode);\n  }\n\n  /**\n   * Returns the HTML of the node.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {String}\n   */\n  html() {\n    return this.single('html', (n) => {\n      if (this.type() === null) return null;\n      const adapter = getAdapter(this[OPTIONS]);\n      const renderer = adapter.createRenderer({ ...this[OPTIONS], mode: 'string' });\n      return renderer.render(adapter.nodeToElement(n));\n    });\n  }\n\n  /**\n   * Returns the current node rendered to HTML and wrapped in a CheerioWrapper.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {CheerioWrapper}\n   */\n  render() {\n    const html = this.html();\n    return loadCheerioRoot(html);\n  }\n\n  /**\n   * Used to simulate events. Pass an eventname and (optionally) event arguments. This method of\n   * testing events should be met with some skepticism.\n   *\n   * @param {String} event\n   * @param {Array} args\n   * @returns {ShallowWrapper}\n   */\n  simulate(event, ...args) {\n    return this.single('simulate', (n) => {\n      this[RENDERER].simulateEvent(n, event, ...args);\n      this[ROOT].update();\n      return this;\n    });\n  }\n\n  /**\n   * Used to simulate throwing a rendering error. Pass an error to throw.\n   *\n   * @param {String} error\n   * @returns {ShallowWrapper}\n   */\n  simulateError(error) {\n    // in shallow, the \"root\" is the \"rendered\" thing.\n\n    return this.single('simulateError', (thisNode) => {\n      if (thisNode.nodeType === 'host') {\n        throw new TypeError('ShallowWrapper::simulateError() can only be called on custom components');\n      }\n\n      const renderer = this[RENDERER];\n      if (typeof renderer.simulateError !== 'function') {\n        throw new TypeError('your adapter does not support `simulateError`. Try upgrading it!');\n      }\n\n      const rootNode = getRootNodeInternal(this);\n      const nodeHierarchy = [thisNode].concat(nodeParents(this, thisNode));\n      renderer.simulateError(nodeHierarchy, rootNode, error);\n\n      return this;\n    });\n  }\n\n  /**\n   * Returns the props hash for the current node of the wrapper.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @returns {Object}\n   */\n  props() {\n    return this.single('props', propsOfNode);\n  }\n\n  /**\n   * Returns the state hash for the root node of the wrapper. Optionally pass in a prop name and it\n   * will return just that value.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {String} name (optional)\n   * @returns {*}\n   */\n  state(name) {\n    if (this[ROOT] !== this) {\n      throw new Error('ShallowWrapper::state() can only be called on the root');\n    }\n    if (this.instance() === null || this[RENDERER].getNode().nodeType !== 'class') {\n      throw new Error('ShallowWrapper::state() can only be called on class components');\n    }\n    const _state = this.single('state', () => this.instance().state);\n    if (typeof name !== 'undefined') {\n      if (_state == null) {\n        throw new TypeError(`ShallowWrapper::state(\"${name}\") requires that \\`state\\` not be \\`null\\` or \\`undefined\\``);\n      }\n      return _state[name];\n    }\n    return _state;\n  }\n\n  /**\n   * Returns the context hash for the root node of the wrapper.\n   * Optionally pass in a prop name and it will return just that value.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {String} name (optional)\n   * @returns {*}\n   */\n  context(name) {\n    if (this[ROOT] !== this) {\n      throw new Error('ShallowWrapper::context() can only be called on the root');\n    }\n    if (!this[OPTIONS].context) {\n      throw new Error('ShallowWrapper::context() can only be called on a wrapper that was originally passed a context option');\n    }\n    if (this.instance() === null) {\n      throw new Error('ShallowWrapper::context() can only be called on wrapped nodes that have a non-null instance');\n    }\n    const _context = this.single('context', () => this.instance().context);\n    if (name) {\n      return _context[name];\n    }\n    return _context;\n  }\n\n  /**\n   * Returns a new wrapper with all of the children of the current wrapper.\n   *\n   * @param {EnzymeSelector} [selector]\n   * @returns {ShallowWrapper}\n   */\n  children(selector) {\n    const allChildren = this.flatMap((n) => childrenOfNode(n.getNodeInternal()));\n    return selector ? allChildren.filter(selector) : allChildren;\n  }\n\n  /**\n   * Returns a new wrapper with a specific child\n   *\n   * @param {Number} [index]\n   * @returns {ShallowWrapper}\n   */\n  childAt(index) {\n    return this.single('childAt', () => this.children().at(index));\n  }\n\n  /**\n   * Returns a wrapper around all of the parents/ancestors of the wrapper. Does not include the node\n   * in the current wrapper.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param {EnzymeSelector} [selector]\n   * @returns {ShallowWrapper}\n   */\n  parents(selector) {\n    return this.single('parents', (n) => {\n      const allParents = this.wrap(nodeParents(this, n));\n      return selector ? allParents.filter(selector) : allParents;\n    });\n  }\n\n  /**\n   * Returns a wrapper around the immediate parent of the current node.\n   *\n   * @returns {ShallowWrapper}\n   */\n  parent() {\n    return this.flatMap((n) => [n.parents().get(0)]);\n  }\n\n  /**\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {ShallowWrapper}\n   */\n  closest(selector) {\n    if (this.is(selector)) {\n      return this;\n    }\n    const matchingAncestors = this.parents().filter(selector);\n    return matchingAncestors.length > 0 ? matchingAncestors.first() : this.findWhere(() => false);\n  }\n\n  /**\n   * Shallow renders the current node and returns a shallow wrapper around it.\n   *\n   * NOTE: can only be called on wrapper of a single node.\n   *\n   * @param {Object} options\n   * @returns {ShallowWrapper}\n   */\n  shallow(options = {}) {\n    return this.single('shallow', (n) => {\n      const childOptions = makeInheritedChildOptions(this, options);\n      return this.wrap(getAdapter(this[OPTIONS]).nodeToElement(n), null, childOptions);\n    });\n  }\n\n  /**\n   * Returns the value of prop with the given name of the current node.\n   *\n   * @param propName\n   * @returns {*}\n   */\n  prop(propName) {\n    return this.props()[propName];\n  }\n\n  /**\n   * Used to invoke a function prop.\n   * Will invoke an function prop and return its value.\n   *\n   * @param {String} propName\n   * @returns {Any}\n   */\n  invoke(propName) {\n    return this.single('invoke', () => {\n      const handler = this.prop(propName);\n      if (typeof handler !== 'function') {\n        throw new TypeError('ShallowWrapper::invoke() requires the name of a prop whose value is a function');\n      }\n      return (...args) => {\n        const response = handler(...args);\n        this[ROOT].update();\n        return response;\n      };\n    });\n  }\n\n  /**\n   * Returns a wrapper of the node rendered by the provided render prop.\n   *\n   * @param {String} propName\n   * @returns {Function}\n   */\n  renderProp(propName) {\n    const adapter = getAdapter(this[OPTIONS]);\n    if (typeof adapter.wrap !== 'function') {\n      throw new RangeError('your adapter does not support `wrap`. Try upgrading it!');\n    }\n\n    return this.single('renderProp', (n) => {\n      if (n.nodeType === 'host') {\n        throw new TypeError('ShallowWrapper::renderProp() can only be called on custom components');\n      }\n      if (typeof propName !== 'string') {\n        throw new TypeError('ShallowWrapper::renderProp(): `propName` must be a string');\n      }\n      const props = this.props();\n      if (!has(props, propName)) {\n        throw new Error(`ShallowWrapper::renderProp(): no prop called ${propName} found`);\n      }\n      const propValue = props[propName];\n      if (typeof propValue !== 'function') {\n        throw new TypeError(`ShallowWrapper::renderProp(): expected prop ${propName} to contain a function, but it holds ${typeof propValue}`);\n      }\n\n      return (...args) => {\n        const element = propValue(...args);\n        const wrapped = adapter.wrap(element);\n        return this.wrap(wrapped, null, this[OPTIONS]);\n      };\n    });\n  }\n\n  /**\n   * Returns the key assigned to the current node.\n   *\n   * @returns {String}\n   */\n  key() {\n    return this.single('key', (n) => (n.key === undefined ? null : n.key));\n  }\n\n  /**\n   * Returns the type of the current node of this wrapper. If it's a composite component, this will\n   * be the component constructor. If it's a native DOM node, it will be a string of the tag name.\n   * If it's null, it will be null.\n   *\n   * @returns {String|Function|null}\n   */\n  type() {\n    return this.single('type', (n) => typeOfNode(n));\n  }\n\n  /**\n   * Returns the name of the current node of this wrapper.\n   *\n   * In order of precedence => type.displayName -> type.name -> type.\n   *\n   * @returns {String}\n   */\n  name() {\n    const adapter = getAdapter(this[OPTIONS]);\n    return this.single('name', (n) => (\n      adapter.displayNameOfNode ? adapter.displayNameOfNode(n) : displayNameOfNode(n)\n    ));\n  }\n\n  /**\n   * Returns whether or not the current node has the given class name or not.\n   *\n   * NOTE: can only be called on a wrapper of a single node.\n   *\n   * @param className\n   * @returns {Boolean}\n   */\n  hasClass(className) {\n    if (typeof className === 'string' && className.indexOf('.') !== -1) {\n      // eslint-disable-next-line no-console\n      console.warn('It looks like you\\'re calling `ShallowWrapper::hasClass()` with a CSS selector. hasClass() expects a class name, not a CSS selector.');\n    }\n    return this.single('hasClass', (n) => hasClassName(n, className));\n  }\n\n  /**\n   * Iterates through each node of the current wrapper and executes the provided function with a\n   * wrapper around the corresponding node passed in as the first argument.\n   *\n   * @param {Function} fn\n   * @returns {ShallowWrapper}\n   */\n  forEach(fn) {\n    this.getNodesInternal().forEach((n, i) => fn.call(this, this.wrap(n), i));\n    return this;\n  }\n\n  /**\n   * Maps the current array of nodes to another array. Each node is passed in as a `ShallowWrapper`\n   * to the map function.\n   *\n   * @param {Function} fn\n   * @returns {Array}\n   */\n  map(fn) {\n    return this.getNodesInternal().map((n, i) => fn.call(this, this.wrap(n), i));\n  }\n\n  /**\n   * Reduces the current array of nodes to a value. Each node is passed in as a `ShallowWrapper`\n   * to the reducer function.\n   *\n   * @param {Function} fn - the reducer function\n   * @param {*} initialValue - the initial value\n   * @returns {*}\n   */\n  reduce(fn, initialValue = undefined) {\n    if (arguments.length > 1) {\n      return this.getNodesInternal().reduce(\n        (accum, n, i) => fn.call(this, accum, this.wrap(n), i),\n        initialValue,\n      );\n    }\n    return this.getNodesInternal().reduce((accum, n, i) => fn.call(\n      this,\n      i === 1 ? this.wrap(accum) : accum,\n      this.wrap(n),\n      i,\n    ));\n  }\n\n  /**\n   * Reduces the current array of nodes to another array, from right to left. Each node is passed\n   * in as a `ShallowWrapper` to the reducer function.\n   *\n   * @param {Function} fn - the reducer function\n   * @param {*} initialValue - the initial value\n   * @returns {*}\n   */\n  reduceRight(fn, initialValue = undefined) {\n    if (arguments.length > 1) {\n      return this.getNodesInternal().reduceRight(\n        (accum, n, i) => fn.call(this, accum, this.wrap(n), i),\n        initialValue,\n      );\n    }\n    return this.getNodesInternal().reduceRight((accum, n, i) => fn.call(\n      this,\n      i === 1 ? this.wrap(accum) : accum,\n      this.wrap(n),\n      i,\n    ));\n  }\n\n  /**\n   * Returns a new wrapper with a subset of the nodes of the original wrapper, according to the\n   * rules of `Array#slice`.\n   *\n   * @param {Number} begin\n   * @param {Number} end\n   * @returns {ShallowWrapper}\n   */\n  slice(begin, end) {\n    return this.wrap(this.getNodesInternal().slice(begin, end));\n  }\n\n  /**\n   * Returns whether or not any of the nodes in the wrapper match the provided selector.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {Boolean}\n   */\n  some(selector) {\n    if (this[ROOT] === this) {\n      throw new Error('ShallowWrapper::some() can not be called on the root');\n    }\n    const predicate = buildPredicate(selector);\n    return this.getNodesInternal().some(predicate);\n  }\n\n  /**\n   * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.\n   *\n   * @param {Function} predicate\n   * @returns {Boolean}\n   */\n  someWhere(predicate) {\n    return this.getNodesInternal().some((n, i) => predicate.call(this, this.wrap(n), i));\n  }\n\n  /**\n   * Returns whether or not all of the nodes in the wrapper match the provided selector.\n   *\n   * @param {EnzymeSelector} selector\n   * @returns {Boolean}\n   */\n  every(selector) {\n    const predicate = buildPredicate(selector);\n    return this.getNodesInternal().every(predicate);\n  }\n\n  /**\n   * Returns whether or not any of the nodes in the wrapper pass the provided predicate function.\n   *\n   * @param {Function} predicate\n   * @returns {Boolean}\n   */\n  everyWhere(predicate) {\n    return this.getNodesInternal().every((n, i) => predicate.call(this, this.wrap(n), i));\n  }\n\n  /**\n   * Utility method used to create new wrappers with a mapping function that returns an array of\n   * nodes in response to a single node wrapper. The returned wrapper is a single wrapper around\n   * all of the mapped nodes flattened (and de-duplicated).\n   *\n   * @param {Function} fn\n   * @returns {ShallowWrapper}\n   */\n  flatMap(fn) {\n    const nodes = this.getNodesInternal().map((n, i) => fn.call(this, this.wrap(n), i));\n    const flattened = flat(nodes, 1);\n    return this.wrap(flattened.filter(Boolean));\n  }\n\n  /**\n   * Finds all nodes in the current wrapper nodes' render trees that match the provided predicate\n   * function. The predicate function will receive the nodes inside a ShallowWrapper as its\n   * first argument.\n   *\n   * @param {Function} predicate\n   * @returns {ShallowWrapper}\n   */\n  findWhere(predicate) {\n    return findWhereUnwrapped(this, (n) => {\n      const node = this.wrap(n);\n      return node.length > 0 && predicate(node);\n    });\n  }\n\n  /**\n   * Returns the node at a given index of the current wrapper.\n   *\n   * @param index\n   * @returns {ReactElement}\n   */\n  get(index) {\n    return this.getElements()[index];\n  }\n\n  /**\n   * Returns a wrapper around the node at a given index of the current wrapper.\n   *\n   * @param index\n   * @returns {ShallowWrapper}\n   */\n  at(index) {\n    const nodes = this.getNodesInternal();\n    if (index < nodes.length) {\n      return this.wrap(nodes[index]);\n    }\n    return this.wrap([]);\n  }\n\n  /**\n   * Returns a wrapper around the first node of the current wrapper.\n   *\n   * @returns {ShallowWrapper}\n   */\n  first() {\n    return this.at(0);\n  }\n\n  /**\n   * Returns a wrapper around the last node of the current wrapper.\n   *\n   * @returns {ShallowWrapper}\n   */\n  last() {\n    return this.at(this.length - 1);\n  }\n\n  /**\n   * Delegates to exists()\n   *\n   * @returns {boolean}\n   */\n  isEmpty() {\n    // eslint-disable-next-line no-console\n    console.warn('Enzyme::Deprecated method isEmpty() called, use exists() instead.');\n    return !this.exists();\n  }\n\n  /**\n   * Returns true if the current wrapper has nodes. False otherwise.\n   * If called with a selector it returns `.find(selector).exists()` instead.\n   *\n   * @param {EnzymeSelector} selector (optional)\n   * @returns {boolean}\n   */\n  exists(selector = null) {\n    return arguments.length > 0 ? this.find(selector).exists() : this.length > 0;\n  }\n\n  /**\n   * Utility method that throws an error if the current instance has a length other than one.\n   * This is primarily used to enforce that certain methods are only run on a wrapper when it is\n   * wrapping a single node.\n   *\n   * @param fn\n   * @returns {*}\n   */\n  single(name, fn) {\n    const fnName = typeof name === 'string' ? name : 'unknown';\n    const callback = typeof fn === 'function' ? fn : name;\n    if (this.length !== 1) {\n      throw new Error(`Method ${fnName} is meant to be run on 1 node. ${this.length} found instead.`);\n    }\n    return callback.call(this, this.getNodeInternal());\n  }\n\n  /**\n   * Helpful utility method to create a new wrapper with the same root as the current wrapper, with\n   * any nodes passed in as the first parameter automatically wrapped.\n   *\n   * @param node\n   * @returns {ShallowWrapper}\n   */\n  wrap(node, root = this[ROOT], ...args) {\n    if (node instanceof ShallowWrapper) {\n      return node;\n    }\n    return new ShallowWrapper(node, root, ...args);\n  }\n\n  /**\n   * Returns an HTML-like string of the shallow render for debugging purposes.\n   *\n   * @param {Object} [options] - Property bag of additional options.\n   * @param {boolean} [options.ignoreProps] - if true, props are omitted from the string.\n   * @param {boolean} [options.verbose] - if true, arrays and objects to be verbosely printed.\n   * @returns {String}\n   */\n  debug(options = {}) {\n    return debugNodes(this.getNodesInternal(), options);\n  }\n\n  /**\n   * Invokes intercepter and returns itself. intercepter is called with itself.\n   * This is helpful when debugging nodes in method chains.\n   * @param fn\n   * @returns {ShallowWrapper}\n   */\n  tap(intercepter) {\n    intercepter(this);\n    return this;\n  }\n\n  /**\n   * Primarily useful for HOCs (higher-order components), this method may only be\n   * run on a single, non-DOM node, and will return the node, shallow-rendered.\n   *\n   * @param {Object} options\n   * @returns {ShallowWrapper}\n   */\n  dive(options = {}) {\n    const adapter = getAdapter(this[OPTIONS]);\n    const name = 'dive';\n    return this.single(name, (n) => {\n      if (n && n.nodeType === 'host') {\n        throw new TypeError(`ShallowWrapper::${name}() can not be called on Host Components`);\n      }\n      const el = getAdapter(this[OPTIONS]).nodeToElement(n);\n      if (!isCustomComponentElement(el, adapter)) {\n        throw new TypeError(`ShallowWrapper::${name}() can only be called on components`);\n      }\n      const childOptions = makeInheritedChildOptions(this, options);\n      return this.wrap(el, null, childOptions);\n    });\n  }\n\n  /**\n   * Strips out all the not host-nodes from the list of nodes\n   *\n   * This method is useful if you want to check for the presence of host nodes\n   * (actually rendered HTML elements) ignoring the React nodes.\n   */\n  hostNodes() {\n    return this.filterWhere((n) => typeof n.type() === 'string');\n  }\n}\n\n/**\n * Updates the context of the primary wrapper when the\n * `wrappingComponent` re-renders.\n */\nfunction updatePrimaryRootContext(wrappingComponent) {\n  const adapter = getAdapter(wrappingComponent[OPTIONS]);\n  const primaryWrapper = wrappingComponent[PRIMARY_WRAPPER];\n  const primaryRenderer = primaryWrapper[RENDERER];\n  const primaryNode = primaryRenderer.getNode();\n  const {\n    legacyContext,\n    providerValues,\n  } = getContextFromWrappingComponent(wrappingComponent, adapter);\n  const prevProviderValues = primaryWrapper[PROVIDER_VALUES];\n\n  primaryWrapper.setContext({\n    ...wrappingComponent[PRIMARY_WRAPPER][OPTIONS].context,\n    ...legacyContext,\n  });\n  primaryWrapper[PROVIDER_VALUES] = new Map([...prevProviderValues, ...providerValues]);\n\n  if (typeof adapter.isContextConsumer === 'function' && adapter.isContextConsumer(primaryNode.type)) {\n    const Consumer = primaryNode.type;\n    // Adapters with an `isContextConsumer` method will definitely have a `getProviderFromConsumer`\n    // method.\n    const Provider = adapter.getProviderFromConsumer(Consumer);\n    const newValue = providerValues.get(Provider);\n    const oldValue = prevProviderValues.get(Provider);\n\n    // Use referential comparison like React\n    if (newValue !== oldValue) {\n      primaryWrapper.rerender();\n    }\n  }\n}\n\n/**\n * A *special* \"root\" wrapper that represents the component passed as `wrappingComponent`.\n * It is linked to the primary root such that updates to it will update the primary.\n *\n * @class WrappingComponentWrapper\n */\nclass WrappingComponentWrapper extends ShallowWrapper {\n  constructor(nodes, root, RootFinder) {\n    super(nodes);\n    privateSet(this, PRIMARY_WRAPPER, root);\n    privateSet(this, ROOT_FINDER, RootFinder);\n  }\n\n  /**\n   * Like rerender() on ShallowWrapper, except it also does a \"full render\" of\n   * itself and updates the primary ShallowWrapper's context.\n   */\n  rerender(...args) {\n    const result = super.rerender(...args);\n    updatePrimaryRootContext(this);\n    return result;\n  }\n\n  /**\n   * Like setState() on ShallowWrapper, except it also does a \"full render\" of\n   * itself and updates the primary ShallowWrapper's context.\n   */\n  setState(...args) {\n    const result = super.setState(...args);\n    updatePrimaryRootContext(this);\n    return result;\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  getWrappingComponent() {\n    throw new Error('ShallowWrapper::getWrappingComponent() can only be called on the root');\n  }\n}\n\nif (ITERATOR_SYMBOL) {\n  Object.defineProperty(ShallowWrapper.prototype, ITERATOR_SYMBOL, {\n    configurable: true,\n    value: function iterator() {\n      const iter = this.getNodesInternal()[ITERATOR_SYMBOL]();\n      const adapter = getAdapter(this[OPTIONS]);\n      return {\n        [ITERATOR_SYMBOL]() { return this; },\n        next() {\n          const next = iter.next();\n          if (next.done) {\n            return { done: true };\n          }\n          return {\n            done: false,\n            value: adapter.nodeToElement(next.value),\n          };\n        },\n      };\n    },\n  });\n}\n\nfunction privateWarning(prop, extraMessage) {\n  Object.defineProperty(ShallowWrapper.prototype, prop, {\n    get() {\n      throw new Error(`\n        Attempted to access ShallowWrapper::${prop}, which was previously a private property on\n        Enzyme ShallowWrapper instances, but is no longer and should not be relied upon.\n        ${extraMessage}\n      `);\n    },\n    enumerable: false,\n    configurable: false,\n  });\n}\n\nprivateWarning('node', 'Consider using the getElement() method instead.');\nprivateWarning('nodes', 'Consider using the getElements() method instead.');\nprivateWarning('renderer', '');\nprivateWarning('options', '');\nprivateWarning('complexSelector', '');\n\nexport default ShallowWrapper;\n"]},"metadata":{},"sourceType":"script"}